block includes
  include ../_util-fns

:marked
  Every application starts out with what seems like a simple task: get data, transform them, and show them to users.
  Getting data could be as simple as creating a local variable or as complex as streaming data over a Websocket.
  
  Toda aplicacion se inicia con lo que parece ser una simple tarea: obtener datos, transformarlos, y mostrárselos a los usuarios.
  La obtención de datos podría ser tan simple como la creación de una variable local o tan compleja como la transmisión de datos a través de un Websocket.

  Once data arrive, we could push their raw `toString` values directly to the view.
  That rarely makes for a good user experience.
  E.g., almost everyone prefers a simple birthday date like
  <samp>April 15, 1988</samp> to the original raw string format
  &mdash; <samp>Fri Apr 15 1988 00:00:00 GMT-0700 (Pacific Daylight Time)</samp>.
  
  Una vez que los datos llegan, se podrían llevar sus valores convertidos a cadena directamente a la vista.
  Eso raramente genera una buena experiencia de usuario.
  E.g., casi todos prefieren una fecha de cumpleaños simple como
  <samp>April 15, 1988</samp> que el valor original formateado a cadena
  &mdash; <samp>Fri Apr 15 1988 00:00:00 GMT-0700 (Pacific Daylight Time)</samp>.

  Clearly some values benefit from a bit of massage. We soon discover that we
  desire many of the same transformations repeatedly, both within and across many applications.
  We almost think of them as styles.
  In fact, we'd like to apply them in our HTML templates as we do styles.
  
  Claramente algunos valores se benefician con un poco de maquillaje. Pronto se descubrirá que
  se desean muchas de las mismas transformaciones repetidamente, tanto dentro como a través de muchas aplicaciones.
  Casi se piensa en ellas como estilos.
  De hecho, se querría aplicarlas en las plantillas HTML como se hace con los estilos.

  Introducing Angular pipes, a way to write display-value transformations that we can declare in our HTML!
  Try the <live-example></live-example>.
  
  Introduciendo los pipes de Angular, una manera de escribir transformaciones para presentación de valores que ¡se pueden declarar en el HTML!
  Pruebe el <live-example></live-example>.

.l-main-section
:marked
  ## Using Pipes
  
  ## Utilizando Pipes

  A pipe takes in data as input and transforms it to a desired output.
  We'll illustrate by transforming a component's birthday property into
  a human-friendly date.
  
  Un pipe toma datos como entrada y los transforma a la salida deseada.
  Se explicará transformando la propiedad birthday de un componente a
  una fecha amigable para los humanos.

+makeExample('pipes/ts/app/hero-birthday1.component.ts', null, 'app/hero-birthday1.component.ts')(format='.')

:marked
  Focus on the component's template.
  
  Centrémonos en la plantilla del componente.

+makeExample('pipes/ts/app/app.component.html', 'hero-birthday-template')(format=".")

:marked
  Inside the interpolation expression we flow the component's `birthday` value through the
  [pipe operator](./template-syntax.html#pipe) ( | ) to the [Date pipe](../api/common/index/DatePipe-class.html)
  function on the right. All pipes work this way.
  
  Dentro de la expresión de interpolación se mueve el valor `birthday` del componente a través del
  [operador pipe](./template-syntax.html#pipe) ( | ) al [pipe Date](../api/common/index/DatePipe-class.html)

.l-main-section
:marked
  ## Built-in pipes
  Angular comes with a stock of pipes such as
  `DatePipe`, `UpperCasePipe`, `LowerCasePipe`, `CurrencyPipe`, and `PercentPipe`.
  They are all immediately available for use in any template.
  
  ## Pipes incluídos
  Angular viene con un conjunto de pipes como
  `DatePipe`, `UpperCasePipe`, `LowerCasePipe`, `CurrencyPipe`, y `PercentPipe`.
  Todos ellos inmediatamente disponibles para usarse en cualquier plantilla.

.l-sub-section
  :marked
    Learn more about these and many other built-in pipes in the  the [API Reference](../api/#!?apiFilter=pipe);
    filter for entries that include the word "pipe".
    
    Aprenda más sobre esos y muchos otros pipes incluidos en la [Referencia de la API](../api/#!?apiFilter=pipe);
    filtre por entradas que incluyan la palabra "pipe".

    Angular 2 doesn't have a `FilterPipe` or an `OrderByPipe` for reasons explained in an [appendix below](#no-filter-pipe).
    
    Angular 2 no tiene un `FilterPipe` o un `OrderByPipe` por razones explicadas en el [apéndice abajo](#no-filter-pipe).

.l-main-section
:marked
  ## Parameterizing a Pipe
  
  ## Parametrización de un Pipe

  A pipe may accept any number of optional parameters to fine-tune its output.
  We add parameters to a pipe by following the pipe name with a colon ( : ) and then the parameter value
  (e.g., `currency:'EUR'`). If our pipe accepts multiple parameters, we separate the values with colons (e.g. `slice:1:5`)
  
  Un pipe puede aceptar cualquier número de parámetros opcionales para afinar su salida.
  Se añaden parámetros a un pipe poniendo el nombre del pipe seguido de dos puntos ( : ) y después el valor del parámetro 
   (e.g., `currency:'EUR'`). Si el pipe acepta múltiples parámetros, se separan los valores con dos puntos (e.g. `slice:1:5`)

  We'll modify our birthday template to give the date pipe a format parameter.
  After formatting the hero's April 15th birthday, it should render as **<samp>04/15/88</samp>**:
  
  Se modificará la plantilla birthday para dar al pipe de fecha un parámetro de formato.
  Después de formateado el cumpleaños del héroe April 15th, debería verse como **<samp>04/15/88</samp>**:

+makeExample('pipes/ts/app/app.component.html', 'format-birthday')(format=".")

:marked
  The parameter value can be any valid
  [template expression](./template-syntax.html#template-expressions)
  such as a string literal or a component property.
  In other words, we can control the format through a binding the same way we control the birthday value through a binding.
  
  El valor del parámetro puede ser cualquier válido
  [expresión de plantilla](./template-syntax.html#template-expressions)
  como una cadena de letras o una propiedad de un componente.

  Let's write a second component that *binds* the pipe's format parameter
  to the component's `format` property. Here's the template for that component:
  
  Se escribirá un segundo componente que *enlaza* el parámetro de formato del pipe
  a la propiedad `format` del componente. Aquí está la plantilla para ese componente.

+makeExample('pipes/ts/app/hero-birthday2.component.ts', 'template', 'app/hero-birthday2.component.ts (template)')(format=".")

:marked
  We also added a button to the template and bound its click event to the component's `toggleFormat()` method.
  That method toggles the component's `format` property between a short form
  (`'shortDate'`) and a longer form (`'fullDate'`).
  
  También se añade un botón a la plantilla y se asocia su evento clic al método `toggleFormat()` del componente.
  Ese método manipula la propiedad `format` del componente entre una forma corta 
  (`'shortDate'`) y una larga (`'fullDate'`).

+makeExample('pipes/ts/app/hero-birthday2.component.ts', 'class', 'app/hero-birthday2.component.ts (class)')(format='.')

:marked
  As we click the button, the displayed date alternates between
  "**<samp>04/15/1988</samp>**" and
  "**<samp>Friday, April 15, 1988</samp>**".
  
  Como se haga clic en el botón, las fechas mostradas se alternan entre
  "**<samp>04/15/1988</samp>**" and
  "**<samp>Friday, April 15, 1988</samp>**".

figure.image-display
  img(src='/resources/images/devguide/pipes/date-format-toggle-anim.gif' alt="Date Format Toggle")
:marked

.l-sub-section
  :marked
    Learn more about the `DatePipes` format options in the [API Docs](../api/common/index/DatePipe-class.html).
    
    Aprenda más sobre las opciones de formato para `DatePipes` en la [Documentación de la API](../api/common/index/DatePipe-class.html).

:marked
  ## Chaining pipes
  
  ## Encadenando pipes

  We can chain pipes together in potentially useful combinations.
  In the following example, we chain the birthday to the `DatePipe` and on to the `UpperCasePipe`
  so we can display the birthday in uppercase. The following birthday displays as
  **<samp>APR 15, 1988</samp>**.
  
  Se pueden encadenar pipes juntos en combinaciones potencialmente útiles.
  En el ejemplo siguiente, se encadena el cumpleaños al `DatePipe` y al `UpperCasePipe`
  así que se puede mostrar el cumpleaños en mayúsculas. El siguiente cumpleaños se muestra como
  **<samp>APR 15, 1988</samp>**.

+makeExample('pipes/ts/app/app.component.html', 'chained-birthday')(format=".")

:marked
  This example &mdash; which displays **<samp>FRIDAY, APRIL 15, 1988</samp>** &mdash;
  chains the same pipes as above, but passes in a parameter to `date` as well.
  
  Este ejemplo &mdash; que muestra **<samp>FRIDAY, APRIL 15, 1988</samp>** &mdash;
  encadena los mismos pipes como arriba, pero pasa en un parámetro a `date` también.

+makeExample('pipes/ts/app/app.component.html', 'chained-parameter-birthday')(format=".")

.l-main-section
:marked
  ## Custom Pipes
  
  ## Pipes personalizados

  We can write our own custom pipes.
  Here's a custom pipe named `ExponentialStrengthPipe` that can boost a hero's powers:
  
  Se pueden escribir pipes personalizados.
  Aquí está un pipe personalizado llamado `ExponentialStrengthPipe` que puede aumentar los poderes del héroe:

+makeExample('pipes/ts/app/exponential-strength.pipe.ts', null, 'app/exponential-strength.pipe.ts')(format=".")

:marked
  This pipe definition reveals several key points:
  
  Esta definición del pipe revela varios puntos clave:

  * A pipe is a class decorated with pipe metadata.
  
  * Un pipe es una clase decorada con el metadato pipe.

  * The pipe class implements the `PipeTransform` interface's `transform` method that
  accepts an input value followed by optional parameters and returns the transformed value.
  
  * La clase pipe implementa la interface `PipeTransform` del método `transform` que
  acepta un valor de entrada seguido de parámetros opcionales y regresa el valor transformado.

  * There will be one additional argument to the `transform` method for each parameter passed to the pipe.
  Our pipe has one such parameter: the `exponent`.
  
  * Habrá un argumento adicional al método `transform` para cada parámetro pasado al pipe.
  El pipe tiene un parámetro: el `exponent`.

  * We tell Angular that this is a pipe by applying the
  `@Pipe` #{_decorator} which we import from the core Angular library.
  
  * Se le dice a Angular que este es un pipe aplicando el
  #{_decorador} `@Pipe` que se importa de la librería core de Angular.

  * The `@Pipe` #{_decorator} allows us to define the
     pipe name that we'll use within template expressions. It must be a valid JavaScript identifier.
     Our pipe's name is `exponentialStrength`.
  
  * El #{_decorador} `@Pipe` permite definir el
     nombre del pipe que se utilizará sobre las expresiones de plantilla. Debe ser un identificador JavaScript válido.
     El nombre del pipe es `exponentialStrength`.

.l-sub-section
  :marked
    ### The *PipeTransform* Interface
    
    ### La interfaz *PipeTransform*

    The `transform` method is essential to a pipe.
    The `PipeTransform` *interface* defines that method and guides both tooling and the compiler.
    It is technically optional; Angular looks for and executes the `transform` method regardless.
    
    El método `transform` es esencial para un pipe.
    La *interfaz* `PipeTransform` define este método y orinta tanto las herramientas como al compilador.
    Es técnicamente opcional; Angular busca y ejecuta el método `transform` independientemente.

:marked
  Now we need a component to demonstrate our pipe.
  
  Ahora se necesita un componente para demostrar el pipe.
+makeExample('pipes/ts/app/power-booster.component.ts',null,'app/power-booster.component.ts')(format='.')
figure.image-display
  img(src='/resources/images/devguide/pipes/power-booster.png' alt="Power Booster")

:marked
  Two things to note:
  1. We use our custom pipe the same way we use the built-in pipes.
  
  Dos cosas notables
  1. Se utiliza un pipe personalizado de la misma manera que se utilizan los pipes incluidos.

  1. We must include our pipe in the `pipes` #{_array} of the `@Component` #{_decorator}.
  
  1. Se debe incluir el pipe en el arreglo `pipes` del #{_decorador} `@Component`.

.callout.is-helpful
  header Remember the pipes #{_array}!
  :marked
    Angular reports an error if we neglect to list our custom pipe.
    We didn't list the `DatePipe` in our previous example because all
    Angular built-in pipes are pre-registered.
    Custom pipes must be registered manually.
    
    Angular reporta un error si se olvida listar el pipe personalizado.
    No se listó el `DatePipe` en el ejemplo anterior porque todos
    los pipes de Angular incluidos ya están registrados.

:marked
  If we try the <live-example></live-example>,
  we can probe its behavior by changing the value and the optional exponent in the template.
  
  Si se prueba el <live-example></live-example>,
  se puede examinar su comportamiento cambiando el valor y el exponente opcional en la plantilla.

  ## Power Boost Calculator (extra-credit)
  
  ## Calculadora de aumento de potencia (crédito adicional)

  It's not much fun updating the template to test our custom pipe.
  We could upgrade the example to a "Power Boost Calculator" that combines
  our pipe and two-way data binding with `ngModel`.
  
  No es muy divertido actualizar la plantilla para probar el pipe personalizado.
  Se podría mejorar el ejemplo a una "Calculadora de aumento de potencia" que combine
  el pipe y el two-way data binding con `ngModel`.

+makeExample('pipes/ts/app/power-boost-calculator.component.ts', null, '/app/power-boost-calculator.component.ts')(format='.')

figure.image-display
  img(src='/resources/images/devguide/pipes/power-boost-calculator-anim.gif' alt="Power Boost Calculator")

.l-main-section
a#change-detection
:marked
  ## Pipes and Change Detection
  
  ## Pipes y detección de cambio

  Angular looks for changes to data-bound values through a *change detection* process that runs after every JavaScript event:
  every keystroke, mouse move, timer tick, and server response. This could be expensive.
  Angular strives to lower the cost whenever possible and appropriate.
  
  Angular busca cambios para valores de datos enlazados a través de un proceso de *detección de cambio* que se ejecuta después de cada evento JavaScript:
  cada pulsación de teclas, movimiento del mouse, instante de temporizador y respuesta del servidor. Esto podría ser costoso.
  Angular se esfuerza para disminuir el costo cuando sea posible y apropiado.

  Angular picks a simpler, faster change detection algorithm when we use a pipe. Let's see how.
  
  Angular toma un simple, rápido algoritmo de detección de cambio cuando se utiliza un pipe. Veamos cómo.

  ### No pipe
  
  ### Sin pipe

  The component in our next example uses the default, aggressive change detection strategy to monitor and update
  its display of every hero in the `heroes` #{_array}. Here's the template:
  
  El componente en el siguiente ejemplo usa la agresiva estrategia de detección de cambio por defecto para monitorear y actualizar
  lo que se muestra de cada héroe en el #{_arreglo} `heroes`. Aquí está la plantilla.

+makeExample('pipes/ts/app/flying-heroes.component.html', 'template-1', 'app/flying-heroes.component.html (v1)')(format='.')

:marked
  The companion component class provides heroes, adds new heroes into the #{_array}, and can reset the #{_array}.
  
  La clase componente compañera proporciona héroes, agrega nuevos héroes en el #{_arreglo} y puede restablecer el #{_arreglo}.
+makeExample('pipes/ts/app/flying-heroes.component.ts', 'v1', 'app/flying-heroes.component.ts (v1)')(format='.')

:marked
  We can add a new hero and Angular updates the display when we do.
  The `reset` button replaces `heroes` with a new #{_array} of the original heroes and Angular updates the display when we do.
  If we added the ability to remove or change a hero, Angular would detect those changes too and update the display as well.
  
  Se puede agregar un nuevo héroe y Angular actualiza lo que se muestra cuando lo hace.
  El botón `reset` reemplaza `heroes` con un nuevo #{_arreglo} de los héroes originales y Angular actualiza lo que se muestra cuando lo hace.
  Si se agrega la habilidad para eliminar o modificar un héroe, Angular detectaría también esos cambios y actualizaría lo que se muestra también.

  ### Flying Heroes pipe
  
  ### Pipe de héroes voladores

  Let's add a `FlyingHeroesPipe` to the `*ngFor` repeater that filters the list of heroes to just those heroes who can fly.
  
  Se añadirá un `FlyingHeroesPipe` al repetidor `*ngFor` que filtre la lista de héroes para aquellos héroes que pueden volar.
+makeExample('pipes/ts/app/flying-heroes.component.html', 'template-flying-heroes', 'app/flying-heroes.component.html (flyers)')(format='.')
:marked
  Here's the `FlyingHeroesPipe` implementation which follows the pattern for custom pipes we saw earlier.
  
  Aquí esta la implementación del `FlyingHeroesPipe` que sigue el patrón para pipes personalizados visto anteriormente.
+makeExample('pipes/ts/app/flying-heroes.pipe.ts', 'pure', 'app/flying-heroes.pipe.ts')(format='.')

:marked
  When we run the sample now we see odd behavior (try it in the <live-example></live-example>).
  Every hero we add is a flying hero but none of them are displayed.
  
  Cuando se ejecuta el ejemplo ahora se observa un comportamiento extraño (mire el <live-example></live-example>).
  Todos los héroes que se agregan son héroes voladores pero ninguno se muestra.

  Although we're not getting the behavior we want, Angular isn't broken.
  It's just using a different change detection algorithm &mdash; one that ignores changes to the list or any of its items.
  
  A pesar de que no se obtiene el comportamiento esperado, Angular no deja de funcionar.
  Está solo utilizando un algoritmo diferente de detección de cambio &mdash; uno que ignora cambios a la lista o cualquiera de sus elementos.

  Look at how we're adding a new hero:
  
  Mire cómo se está agregando un nuevo héroe.
+makeExample('pipes/ts/app/flying-heroes.component.ts', 'push')(format='.')
:marked
  We're adding the new hero into the `heroes` #{_array}.  The reference to the #{_array} hasn't changed.
  It's the same #{_array}. That's all Angular cares about. From its perspective, *same #{_array}, no change, no display update*.
  
  Se está agregando el nuevo héroe al #{_arreglo} `heroes`. La referencia al #{_arreglo} no ha cambiado.
  Es el mismo #{_arreglo}. Es todo de lo que se preocupa Angular. Desde su perspectiva, el mismo #{_arreglo}, sin cambio, no muestra actualización*.

  We can fix that. Let's create a new #{_array} with the new hero appended and assign that to `heroes`.
  This time Angular detects that the #{_array} reference has changed.
  It executes the pipe and updates the display with the new #{_array} which includes the new flying hero.
  
  Se puede solucionar eso. Se creará un nuevo #{_arreglo} con el nuevo héroe agregado y se asignará eso a `heroes`.
  Esta vez Angular detecta que la referencia al #{_arreglo} ha cambiado.
  Ejecuta el pipe y actualiza lo que se muestra con el nuevo #{_arreglo} que incluye el nuevo héroe volador.

  *If we **mutate** the #{_array}, no pipe is invoked and no display updated;
  if we **replace** the #{_array}, then the pipe executes and the display is updated*.
  The *Flying Heroes* extends the
  code with checkbox switches and additional displays to help us experience these effects.
  
  *Si se **altera** el #{_arreglo}, no se invoca al pipe y no se actualiza lo que se muestra;
  si se **reemplaza** el #{_arreglo}, entonces el pipe se ejecuta y se actualiza lo que se muestra*.
  Los *Héroes Voladores* amplían el 
  código con switches checkbox y elementos para mostrar adicionales que ayudan a experimentar esos efectos.

figure.image-display
  img(src='/resources/images/devguide/pipes/flying-heroes-anim.gif' alt="Flying Heroes")

:marked
  Replacing the #{_array} is an efficient way to signal to Angular that it should update the display.
  When do we replace the #{_array}? When the data change.
  That's an easy rule to follow in *this toy* example
  where the only way to change the data is by adding a new hero.
  
  Reemplazar el #{_arreglo} es una manera eficiente para indicar a Angular que debería actualizar lo que se muestra.
  ¿Cuándo se reemplaza el #{_arreglo}? Cuando los datos cambian.
  Esa es una regla fácil de seguir en este ejemplo *de juguete*
  donde la única manera de cambiar los datos es agregando un nuevo héroe.

  More often we don't know when the data have changed,
  especially in applications that mutate data in many ways,
  perhaps in application locations far away.
  A component in such an application usually can't know about those changes.
  Moreover, it's unwise to distort our component design to accommodate a pipe.
  We strive as much as possible to keep the component class independent of the HTML.
  The component should be unaware of pipes.
  
  Más a menudo no se sabe cuando los datos tienen que cambiar,
  especialmente en aplicaciones que alteran los datos de muchas maneras,
  tal vez en lugares lejanos de la aplicación.
  Un componente en una aplicación así usualmente no sabe sobre esos cambios.
  Además, es imprudente distorsionar el diseño del componene para acomodar un pipe.
  Se trata en la mayor manera posibe de mantener la clase del componente independiente del HTML.
  El componente debería se inconsciente de los pipes.

  Perhaps we should consider a different kind of pipe for filtering flying heroes, an *impure pipe*.
  
  Tal vez se debería considerar una manera diferente para filtrar héroes voladores, un *pipe impuro*.

.l-main-section
:marked
  ## Pure and Impure Pipes
  
  ## Pipes puros e impuros

  There are two categories of pipes: **pure** and **impure**.
  Pipes are pure by default. Every pipe we've seen so far has been pure.
  We make a pipe impure by setting its pure flag to false. We could make the `FlyingHeroesPipe`
  impure like this:
  
  Hay dos categorías de pipes: **puros** e **impuros**.
  Los pipes son puros por defecto. Cada pipe visto anteriormente ha sido puro.
  Se hace un pipe impuro configurando su bandera pure a falso. Se podría hacer el `FlyingHeroesPipe`
  impuro de esta manera:

+makeExample('pipes/ts/app/flying-heroes.pipe.ts', 'pipe-decorator')(format='.')

:marked
  Before we do that, let's understand the difference between *pure* and *impure*, starting with a *pure* pipe.
  
  Antes de hacer eso, entendamos la diferencia entre *puro* e *impuro*, iniciando con un pipe *puro*.

  ### Pure pipes
  
  ### Pipes puros

block pure-change
  :marked
    Angular executes a *pure pipe* only when it detects a *pure change* to the input value.
    A ***pure change*** is *either* a change to a primitive input value (`String`, `Number`, `Boolean`, `Symbol`)
    *or* a changed object reference (`Date`, `Array`, `Function`, `Object`).
    
    Angular ejecuta un *pipe puro* solo cuando detecta un *cambio puro* al valor de entrada.
    Un ***cambio puro*** es *ya sea* un cambio en un valor de entrada primitivo (`String`, `Number`, `Boolean`, `Symbol`)
    *o* un cambio de referencia de objeto (`Date`, `Array`, `Function`, `Object`).

:marked
  Angular ignores changes *within* (composite) objects.
  It won't call a pure pipe if we change an input month, add to an input #{_array}, or update an input object property.
  
  Angular ignora los cambios *sobre* objetos (compuestos).
  No llamará un pipe puro si se cambia un mes de entrada, si se agrega un #{_arreglo} de entrada o acualiza una propiedad de un objeto de entrada.

  This may seem restrictive but is is also fast.
  An object reference check is fast &mdash; much faster than a deep check for
  differences &mdash; so Angular can quickly determine if it can skip both the
  pipe execution and a view update.
  
  Esto podría parecer restrictivo pero es rápido también.
  Una verificación de referencia de objeto es rápida &mdash; más rápida que una verificación profunda de
  diferencias &mdash; así que Angular rapidamente determina si puede omitir la 
  ejecución del pipe y la actualización de la vista.

  For this reason, we prefer a pure pipe if we can live with the change detection strategy.
  When we can't, we *may* turn to the impure pipe.
  
  Por esta razón, se prefiere un pipe puro si se puede vivir con la estrategia de detección de cambio.
  Cuando no se puede, se *podría* optar por el pipe impuro.

.l-sub-section
  :marked
    Or we might not use a pipe at all.
    It may be better to pursue the pipe's purpose with a property of the component,
    a point we take up later.
    
    O se podría no usar un pipe del todo.
    Eso podría ser mejor para perseguir el propósito del pipe con una propiedad del componente,
    un punto que se tomará después.

:marked
  ### Impure pipes
  
  ### Pipes impuros

  Angular executes an *impure pipe*  during *every* component change detection cycle.
  An impure pipe will be called a lot, as often as every keystroke or mouse-move.
  
  Angular ejecuta un *pipe impuro* durante *cada* ciclo de detección de cambio del componente.
  Un pipe impuro será llamado muchas veces, tan a menudo como cada pulsación de tecla o movimiento del mouse.

  With that concern in mind, we must implement an impure pipe with great care.
  An expensive, long-running pipe could destroy the user experience.
  
  Con ese asunto en mente, se debe implementar un pipe impuro con mucho cuidado.

  <a id="impure-flying-heroes"></a>
  ### An impure *FlyingHeroesPipe*
  
  ### Un *FlyingHeroesPipe* impuro

  A flip of the switch turns our `FlyingHeroesPipe` into a `FlyingHeroesImpurePipe`.
  Here's the complete implementation:
  
  Un toque en el switch torna el `FlyingHeroesPipe` a un `FlyingHeroesImpurePipe`.
+makeTabs(
'pipes/ts/app/flying-heroes.pipe.ts, pipes/ts/app/flying-heroes.pipe.ts',
'impure, pure',
'FlyingHeroesImpurePipe, FlyingHeroesPipe')(format='.')

:marked
  We inherit from `FlyingHeroesPipe` to prove the point that nothing changed internally.
  The only difference is the `pure` flag in the pipe metadata.
  
  Se hereda de `FlyingHeroesPipe` para probar el punto de que nada cambia internamente.
  La única diferencia es la bandera `pure` en el metadato del pipe.

  This is a good candidate for an impure pipe because the `transform` function is trivial and fast.
  
  Este es un buen candidato para un pipe impuro porque la función `transform` es trivial y rápida.
+makeExample('pipes/ts/app/flying-heroes.pipe.ts','filter')(format='.')

  We can derive a `FlyingHeroesImpureComponent` that we derive from the `FlyingHeroesComponent`.
+makeExample('pipes/ts/app/flying-heroes.component.ts','impure-component','app/flying-heroes.component.ts (FlyingHeroesImpureComponent)')(format='.')
:marked
  The only substantive change is the pipe.
  We can confirm in the <live-example></live-example> that the _flying heroes_
  display updates as we enter new heroes even when we mutate the `heroes` #{_array}.
  
  El único cambio sustantivo es el pipe.
  Se puede confirmar en el <live-example></live-example> que los _héroes voladores_
  muestran actualizaciones como se ingresen nuevos héroes incluso cuando se altera el #{_arreglo} `heroes`.

- var _dollar = _docsFor === 'ts' ? '$' : '';
h3#async-pipe The impure #[i AsyncPipe]
:marked
  The Angular `AsyncPipe` is an interesting example of an impure pipe.
  The `AsyncPipe` accepts a `#{_Promise}` or `#{_Observable}` as input
  and subscribes to the input automatically, eventually returning the emitted value(s).
  
  El `AsyncPipe` de Angular es un ejemplo interesante de un pipe impuro.
  El `AsyncPipe` acepta una `#{_Promesa} o un `#{_Observable}` como entrada
  y suscribe a la entrada automáticamente, eventualmente regresando los valores emitidos.

  It is also stateful.
  The pipe maintains a subscription to the input `#{_Observable}` and
  keeps delivering values from that `#{_Observable}` as they arrive.
  
  Es también de estado.
  El pipe mantiene una suscripción a la entrada `#{_Observable}` y 
  se mantiene entregando valores del `#{_Observable}` de la forma en que llegan.

  In this next example, we bind an `#{_Observable}` of message strings 
  (`message#{_dollar}`) to a view with the `async` pipe.
  
  En este ejemplo, se enlaza un `#{_Observable}` de cadenas de mensaje 
  (`message#{_dollar}`) a una vista con el pipe `async`.

+makeExample('pipes/ts/app/hero-async-message.component.ts', null, 'app/hero-async-message.component.ts')

:marked
  The Async pipe saves boilerplate in the component code.
  The component doesn't have to subscribe to the async data source,
  it doesn't extract the resolved values and expose them for binding,
  and the component doesn't have to unsubscribe when it is destroyed
  (a potent source of memory leaks).
  
  El pipe Async ahorra redundancias en código del componente.
  El componente no tiene que suscribirse a la fuente de datos asíncrona,
  no extrae los valores resueltos y los expone para binding, 
  y el componente no tiene que desuscribirse cuando se destruye
  (una potente fuente de fugas de memoria).

  ### An impure caching pipe
  
  ### Un pipe impuro de almacenamiento de caché

  Let's write one more impure pipe, a pipe that makes an HTTP request to the server.
  Normally, that's a horrible idea.
  It's probably a horrible idea no matter what we do.
  We're forging ahead anyway to make a point.
  Remember that impure pipes are called every few microseconds.
  If we're not careful, this pipe will punish the server with requests.
  
  Se escribirá un pipe impuro más, un pipe que hace peticiones HTTP al servidor.
  Normalmente, esa es una horrible idea.
  Es probablemente una horrible idea sin importar lo que hagamos.
  Seguimos adelante de todas maneras para hacer una notación.
  Recuerde que los pipes impuros son llamados cada pocos microsegundos.
  Si no se tiene cuidado, este pipe castigará al servidor con peticiones.
  
  We are careful. Our pipe only makes a server call if the request URL has changed.
  It caches the request URL and waits for a result which it also caches when it arrives.
  The pipe returns the cached result (which is null while a request is in flight)
  after every Angular call and only contacts the server as necessary.
  
  Tenemos cuidado. El pipe solo hace una llamada al servidor si la URL de petición ha cambiado.
  Almacena la URL de petición y espera a un resultado que también almacena cuando llega.
  El pipe regresa el resultado almacenado (que es nulo mientras una petición está viajando)
  después de cada llamada de Angular y solo contacta al servidor si es necesario.

  Here's the code, which uses the [Angular http](server-communication.html) facility
  to retrieve a `heroes.json` file:
  
  Aquí está el código, que utiliza el [http de Angular](server-communication.html) que fácilmente
  trae un archivo `heroes.json`. 

+makeExample('pipes/ts/app/fetch-json.pipe.ts', null, 'app/fetch-json.pipe.ts')
:marked
  Then we demonstrate it in a harness component whose template defines two bindings to this pipe.
  
  Después se demuestra en un componente arnés del cual su plantilla define dos bindings a este pipe.
+makeExample('pipes/ts/app/hero-list.component.ts', 'template', 'app/hero-list.component.ts (template)')
:marked
  Despite the two bindings and what we know to be frequent pipe calls,
  the nework tab in the browser developer tools confirms that there is only one request for the file.
  
  A pesar de los dos bindings y lo que se sabe de las llamadas frecuentes del pipe,
  la pestaña network en las herramientas para desarrollador en el navegador confirma que hay solo una petición para el archivo.

  The component renders like this:
  
  El componente muestra algo así:

figure.image-display
  img(src='/resources/images/devguide/pipes/hero-list.png' alt="Hero List")

:marked
  ### *JsonPipe*
  
  ### *JsonPipe*

  The second binding involving the `FetchPipe` uses more pipe chaining.
  We take the same fetched results displayed in the first binding
  and display them again, this time in JSON format by chaining through to the built-in `JsonPipe`.
  
  El segundo binding que implica el `FetchPipe` utiliza más el encadenamiento de pipes.
  Se toman los mismos resultados que se trajeron y mostraron en el primer binding
  y los muestra de nuevo, esta vez en formato JSON encadenando a través del `JsonPipe` incluido.

.callout.is-helpful
  header Debugging with the json pipe
  :marked
    The [JsonPipe](../api/common/index/JsonPipe-class.html)
    provides an easy way to diagnosis a mysteriously failing data binding or
    inspect an object for future binding.
    
    El [JsonPipe](../api/common/index/JsonPipe-class.html)
    proporciona una manera fácil de diagnosticar misteriosamente la falla de binding de datos o
    inspeccionar un objeto para un futuro binding.

:marked
  Here's the complete component implementation:
  
  Aquí está la implementación completa del componente:

+makeExample('pipes/ts/app/hero-list.component.ts', null, 'app/hero-list.component.ts')

a(id="pure-pipe-pure-fn")
:marked
  ### Pure pipes and pure functions
  
  ### Pipes puros y funciones puras

  A pure pipe uses pure functions.
  Pure functions process inputs and return values without detectable side-effects.
  Given the same input they should always return the same output.
  
  Un pipe puro utiliza funciones puras.
  Las funciones puras procesan entradas y regresan valores sin efectos secundarios detectables.
  Dada la misma entrada deberían siempre regresar la misma salida.

  The pipes we saw earlier in this chapter were implemented with pure functions.
  The built-in `DatePipe` is a pure pipe with a pure function implementation.
  So is our `ExponentialStrengthPipe`.
  So is our `FlyingHeroesPipe`.
  A few steps back we reviewed the `FlyingHeroesImpurePipe` &mdash; *an impure pipe with a pure function*.
  
  Los pipes que vimos anteriormente en este capítulo fueron implementados con funciones puras.
  El `DatePipe` incluido es un pipe puro con una implementación de función pura.
  Así es el `ExponentialStrengthPipe`.
  Así es el `FlyingHeroesPipe`.
  
  But a *pure pipe* must always be implemented with a *pure function*. Failure to heed this warning will bring about many a console errors regarding expressions that have changed after they were checked.
  
  Pero un *pipe puro* debe siempre ser implementado con una *función pura*. La omisión de esta advertencia generará muchos errores en consola sobre expresiones que han cambiado después de que fueron verificadas.

.l-main-section
:marked
  ## Next Steps
  
  ## Pasos siguientes

  Pipes are a great way to encapsulate and share common display-value
  transformations. We use them like styles, dropping them
  into our templates expressions to enrich the appeal and usability
  of our views.
  
  Los pipes son una manera grandiosa de encapsular y compartir transformaciones
  de valores comunes mostrados. Se utilizan como estilos, llevándolos
  a las expresiones de plantilla para enriquecer la apariencia y la usabilidad
  en las vistas.

  Explore Angular's inventory of built-in pipes in the [API Reference](../api/#!?apiFilter=pipe).
  Try writing a custom pipe and perhaps contributing it to the community.
  
  Explore el inventario de los pipes incluidos en Angular en la [Referencia de la API](../api/#!?apiFilter=pipe).
  Trate de escribir un pipe personalizado y tal vez contribuir con él a la comunidad.

a(id="no-filter-pipe")
.l-main-section
:marked
  ## No *FilterPipe* or *OrderByPipe*
  
  ## Sin *FilterPipe* u *OrderByPipe*

  Angular does not ship with pipes for filtering or sorting lists.
  Developers familiar with Angular 1 know these as `filter` and `orderBy`.
  There are no equivalents in Angular 2.
  
  Angular no viene con pipes para filtrar u ordenar listas.
  Los desarrolladores familiarizados con Angular 1 los conocen como `filter` y `orderBy`.
  No hay equivalentes en Angular 2.

  This is not an oversight. Angular 2 is unlikely to offer such pipes because
  (a) they perform poorly and (b) they prevent aggressive minification.
  Both `filter` and `orderBy` require parameters that reference object properties.
  We learned earlier that such pipes must be  [*impure*](#pure-and-impure-pipes) and that
  Angular calls impure pipes in almost every change detection cycle.
  
  Esto no es una equivocación. Es poco probable que Angular 2 ofrezca tales pipes porque
  (a) funcionan mal e (b) impiden la minificación agresiva.
  Ambos `filter` y `orderBy` requieren parámetros que referencían propiedades de objetos.
  Aprendimos anteriormente que tales pipes deben ser  [*impuros*](#pure-and-impure-pipes) y que
  Angular llama a los pipes impuros en casi todo el ciclo de detección de cambio.

  Filtering and especially sorting are expensive operations.
  The user experience can degrade severely for even moderate sized lists when Angular calls these pipe methods many times per second.
  The `filter` and `orderBy` have often been abused in Angular 1 apps, leading to complaints that Angular itself is slow.
  That charge is fair in the indirect sense that Angular 1 prepared this performance trap
  by offering `filter` and `orderBy` in the first place.
  
  El filtrado y especialmente el ordenamiento son operaciones costosas.
  La experiencia del usuario puede degradarse severamente incluso para listas de tamaño moderado cuando Angular llama estos métodos pipe muchas veces por segundo.
  El `filter` y `orderBy` a menudo han sido objetos de abuso en aplicaciones de Angular 1, dando lugar a quejas de que Angular es lento por si mismo.
  Esa carga es justa en el sentido de que Angular 1 preparó esta trampa de rendimiento
  ofreciendo `filter` y `orderBy` en el primer lugar.

  The minification hazard is also compelling if less obvious. Imagine a sorting pipe applied to a list of heroes.
  We might sort the list by hero `name` and `planet` of origin properties something like this:
  
  El peligro de minificación es también convincente si es menos obvio. Imagine un pipe de ordenamiento aplicado a la lista de héroes.
  Se podría ordenar la lista por `name` y `planet` de las propiedades del origen del héroe algo así:
code-example(language="html")
&lt;!-- NOT REAL CODE! -->
&lt;div *ngFor="let hero of heroes | orderBy:'name,planet'">&lt;/div>
:marked
  We identify the sort fields by text strings, expecting the pipe to reference a property value by indexing
  (e.g., `hero['name']`).
  Unfortunately, aggressive minification *munges* the `Hero` property names so that `Hero.name` and `Hero.planet`
  becomes something like `Hero.a` and `Hero.b`. Clearly `hero['name']` is not going to work.
  
  Se identifican los campos ordenados por cadenas de texto, esperando al pipe para referenciar un valor de una propiedad indexando
  (e.g., `hero['name']`).
  Desafortunadamente, la minificación agresiva *acorta* los nombres de las propiedades de `Hero` de tal manera que `Hero.name` y `Hero.planet`
  se convierten en algo como `Hero.a` y `Hero.b`. Evidentemente `hero['name']` no va a funcionar.

  Some of us may not care to minify this aggressively. That's *our* choice.
  But the Angular product should not prevent someone else from minifying aggressively.
  Therefore, the Angular team decided that everything shipped in Angular will minify safely.
  
  Algunos no tenemos cuidado para minificar esto agresivamente. Es *nuestra* elección.
  Pero el producto de Angular no debería prevenir a alguien más de la minificación agresiva.
  Por lo tanto, el equipo de Angular decidió que toda entrega en Angular será minificada de manera segura.

  The Angular team and many experienced Angular developers strongly recommend that you move
  filtering and sorting logic into the component itself.
  The component can expose a `filteredHeroes` or `sortedHeroes` property and take control
  over when and how often to execute the supporting logic.
  Any capabilities that you would have put in a pipe and shared across the app can be
  written in a filtering/sorting service and injected into the component.
  
  El equipo de Angular y muchos desarrolladores experimentados de Angular recomiendan fuertemente que se mueva
  la lógica de filtrado y ordenamiento al componente en si.
  El componente puede exponer una propiedad `filteredHeroes` o `sortedHeroes` y tomar el control
  de cuándo y con qué frecuencia ejecutar la lógica soportada.
  Todas las capacidades que se tendrían que poner en un pipe y compartirlas en la aplicación pueden ser
  escritas en un servicio de filtrado/ordenamiento y ser inyectados al componente.

  If these performance and minification considerations do not apply to you, you can always create your own such pipes
  (along the lines of the [FlyingHeroesPipe](#impure-flying-heroes)) or find them in the community.
  
  Si estas consideraciones de rendimiento y minificación no aplican para usted, puede siempre crear sus propios pipes
  (a lo largo de las líneas del [FlyingHeroesPipe](#impure-flying-heroes)) o buscarlos en la comunidad.
