block includes
  include ../_util-fns
  - var _library_module = 'library module'
  - var _at_angular = '@angular'

:marked
  Angular 2 is a framework to help us build client applications in HTML and
  either JavaScript or a language (like Dart or TypeScript) that compiles to JavaScript.

  Angular 2 es un framework que nos ayuda a desarrollar aplicaciones del lado del cliente en HTML y 
  con JavaScript o algún lenguaje (como Dart o TypeScript) que se compile a JavaScript.
  
block angular-parts
  :marked
    The framework consists of several cooperating libraries, some of them core and some optional.

    El framework consta de varias librerías que cooperan entre sí, algunas son de funcionalidad principal y otras opcionales.

:marked
  With Angular, we write applications by composing HTML *templates* with Angularized-markup,
  writing *component* classes to manage those templates, adding application logic in *services*,
  and handing the top root component to Angular's *bootstrapper*.

  Para hacer aplicaciones con Angular, se componen *plantillas* HTML con markup-Angularizado,
  se escriben clases de *componentes* para manipular esas plantillas, se agrega la lógica de la aplicación en *servicios*
  y se pasa el componente raíz al *bootstrapper* de Angular.
  
  Angular takes over, presenting our application content in a browser and
  responding to user interactions according to the instructions we provided.

  Angular se hace cargo de presentar el contenido de nuestra aplicación en el navegador y
  de responder a interacciones del usuario de acuerdo a las instrucciones que le proporcionamos.
  
  Of course there is more to it than this.
  We'll learn the details when we dive into the guide chapters.
  Let's get the big picture first.
  
  Por supuesto que hay mucho más que esto,
  más adelante aprenderemos los detalles cuando nos adentremos en los capítulos de la guía;
  pero primero conozcamos el panorama general.

figure
  img(src="/resources/images/devguide/architecture/overview2.png" alt="overview" style="margin-left:-40px;" width="700")

:marked
  The architecture diagram identifies the eight main building blocks of an Angular 2 application:
  
  El diagrama de arquitectura identifica los ocho bloques principales que conforman una aplicacion de Angular 2:

  1. [Modules](#modules)
  1. [Components](#components)
  1. [Templates](#templates)
  1. [Metadata](#metadata)
  1. [Data binding](#data-binding)
  1. [Directives](#directives)
  1. [Services](#services)
  1. [Dependency injection](#dependency-injection)
  
  1. [Módulos](#modules)
  1. [Componentes](#components)
  1. [Plantillas](#templates)
  1. [Metadatos](#metadata)
  1. [Data binding](#data-binding)
  1. [Directivas](#directives)
  1. [Servicios](#services)
  1. [Inyección de Dependencias](#dependency-injection)

  Learn these, and we're on our way.
  
  Apréndelos y estarás en el camino correcto.

.l-sub-section
  p The code referenced in this chapter is available as a #[+liveExampleLink2()].

  p El código referenciado en este capítulo está disponible como un #[+liveExampleLink2()].

.l-main-section
:marked
  ## Modules
  
  ## Módulos
figure
  img(src="/resources/images/devguide/architecture/module.png" alt="Component" align="left" style="width:240px; margin-left:-40px;margin-right:10px" )
:marked
  Angular apps are modular.
  
  Las aplicaciones de Angular son modulares.

  In general we assemble our application from many **modules**.
  
  En general, ensamblamos nuestra aplicación con muchos de estos **módulos**.

  A typical module is a cohesive block of code dedicated to a single purpose.
  A module **exports** something of value in that code, typically one thing such as a class.
  <br clear="all"><br>
  
  Un módulo típico, es un bloque coherente de código dedicado a un solo propósito.
  Un módulo **exporta** algo de valor en ese código, típicamente algo como una clase.
  <br clear="all"><br>
  
block modules-in-dart
  //- N/A

block modules-are-optional
  .l-sub-section
    :marked
       ### Modules are optional
       We highly recommend modular design. TypeScript has great support for ES2015 module syntax and our chapters assume we're taking a modular
       approach using that syntax. That's why we list *Module* among the basic building blocks.
       
       ### Los módulos son opcionales
       Recomendamos mucho un diseño modular. TypeScript tiene un gran soporte para la sintaxis de módulos ES2015 y nuestros capítulos asumen que hablamos de un 
       enfoque usando dicha sintaxis. Es por eso que listamos *Módulo* entre uno de los bloques básicos.

       Angular itself doesn't require a modular approach nor this particular syntax. Don't use it if you don't want it.
       Each chapter has plenty to offer after you steer clear of the `import` and `export` statements.
       
       Angular en sí, no requiere un enfoque modular ni esta sintaxis en particular. Puede no usarse si no se quiere.
       Cada capítulo tiene mucho que ofrecer al alejarse de las declaraciones `import` y `export`.

       Find setup and organization clues in the JavaScript track (select it from the combo-box at the top of this page)
       which demonstrates Angular 2 development with plain old JavaScript and no module system.
       
       Encuentra pistas de configuración y organización en el track de JavaScript (seleccionelo de la lista desplegable en la parte superior de esta página)
       el cual muestra el desarrollo de Angular 2 con solo JavaScript y no un sistema modular.

- var _app_comp_filename = _docsFor == 'dart' ? 'app_component.dart' : 'app.component.ts';
:marked
  Perhaps the first module we meet is a module that exports a *component* class.
  The component is one of the basic Angular blocks, we write a lot of them,
  and we'll talk about components in the next segment. For the moment it is enough to know that a
  component class is the kind of thing we'd export from a module.
  
  Quizás el primer módulo que conocemos es uno que exporta una clase de *componente*.
  El componente es uno de los bloques básicos de Angular, haremos muchos de ellos y
  hablaremos acerca de los componentes en el siguiente segmento de un módulo.

  Most applications have an `AppComponent`. By convention, we'll find it in a file named `!{_app_comp_filename}`.
  Look inside such a file and we'll see a declaration such as this one.
  
  La mayoría de aplicaciones tiene un `AppComponent`. Por convención, lo encontraremos en un archivo llamado `!{_app_comp_filename}`.
  Mira dentro de dicho archivo y verás una declaración tal y como esta:

+makeExcerpt('app/app.component.ts ()', 'export')

block export-qualifier
  :marked
    The `export` statement tells TypeScript that this is a module whose
    `AppComponent` class is public and accessible to other modules of the application.
    
    La declaración `export` le dice a TypeScript que éste es un módulo cuya 
    clase `AppComponent` es pública y accesible a otros módulos de la aplicación.

:marked
  When we need a reference to the `AppComponent`, we **import** it like this:
  
  Cuando necesitamos una referencia al `AppComponent`, lo **importamos** así:

+makeExcerpt('app/main.ts', 'import')

block ts-import
  :marked
    The `import` statement tells the system it can get an `AppComponent` from a module named `app.component`
    located in a neighboring file.
    The **module name** (AKA module id) is often the same as the filename without its extension.
    
    La declaración `import` le indica al sistema que puede obtener el `AppComponent` de un módulo llamado `app.component`.
    El nombre del módulo (también conocido como id) es a menudo el mismo que el archivo pero sin extensión.

:marked
  ### Libraries
  
  ### Librerías

figure
  img(src="/resources/images/devguide/architecture/library-module.png" alt="Component" align="left" style="width:240px; margin-left:-40px;margin-right:10px" )

block angular-library-modules
  :marked
    Some modules are _libraries_ of other modules.
    Angular itself ships as a collection of library modules within several npm packages.
    Their names begin with the `!{_at_angular}` prefix.
    
    Algunos módulos son _librerías_ de otros módulos.
    Angular es una colección de librerías (módulos) dentro de varios paquetes npm.

    Each Angular library contains a [barrel](../glossary.html#barrel) module
    that is actually a public façade over several logically-related private modules.
    
    Cada librería de Angular contiene un [barrel](../glossary.html#barrel) de módulo

:marked
  `!{_at_angular}/core` is the primary Angular library from which we get most of what we need.
  <br clear="all">
  
  `!{_at_angular}/core` es la librería principal de Angular y de la cual obetenemos la mayor parte de lo que necesitamos.
  <br clear="all">

  There are other important Angular libraries too, such as `!{_at_angular}/common`<span if-docs="ts">, 
  `!{_at_angular}/http`</span> and `!{_at_angular}/router`.
  We import what we need from an Angular !{_library_module}.
  
  También hay otras librerías de Angular importantes, como `!{_at_angular}/common`, `!{_at_angular}/router` y `!{_at_angular}/animate`.
  Importamos lo que necesitamos de una !{_library_module} de Angular.

block angular-imports
  :marked
    For example, we import the Angular **`Component` *function*** from `@angular/core` like this:
    
    Por ejemplo, importamos la **función* `Component`*** de Angular `@angular/core` así:
  +makeExcerpt('app/app.component.ts', 'import')
  :marked
    Compare that syntax to our previous import of `AppComponent`.
    
    Compare esa syntaxis con la importación anterior de `AppComponent`.
  +makeExcerpt('app/main.ts', 'import')

  :marked
    Notice the difference?
    In the first case, when importing from an Angular library module,
    the import statement refers to the bare module name, `@angular/core`, *without a path prefix*.
    
    ¿Nota alguna diferencia?
    En el primer caso, cuando se importa de una librería (módulo) de Angular,
    la declaración import se refiere al nombre del módulo, `@angular/core`, *sin un prefijo de ruta*.

    When we import from one of *our* own files, we prefix the module name with the file path.
    In this example we specify  a relative file path (`./`). That means the
    source module is in the same folder (`./`) as the module importing it.
    We could path up and around the application folder structure if the source module were somewhere else.
    
    Cuando importamos uno de *nuestros* propios archivos, ponemos como prefijo la ruta del archivo antes del nombre del módulo.
    En este ejemplo especificamos una ruta de archivo relativa (`./`); es decir 
    el código fuente del módulo está en la misma carpeta (`./`) que el módulo que lo importa.
    Podríamos utilizar cualquier tipo de ruta en nuestra estructura de folders en caso de que el código fuente de nuestro módulo se encontrara en algún otra parte. 
    
  .l-sub-section
    :marked
      We import and export in the ECMAScript 2015 (ES2015) module syntax.
      Learn more about that syntax [here](http://www.2ality.com/2014/09/es6-modules-final.html)
      and many other places on the web.
      
      Importamos y exporatamos en la sintaxis modular de ECMAScript 2015 (ES2015).
      Aprenda más acerca de esta sintaxis [aquí](http://www.2ality.com/2014/09/es6-modules-final.html)
      y en muchos otros lugares de la web.

      The infrastructure *behind* module loading and importing is an important subject.
      But it's a subject outside the scope of this introduction to Angular.
      While we're focused on our application, *import* and *export*
      is about all we need to know.
      
      La infraestructura *detrás* de la carga e importación de módulos es un tema importante,
      pero está fuera del alcance de esta introducción a Angular.
      Mientras nos enfoquemos en nuestra aplicación, *import* y *export* 
      es lo único que debemos saber.

- var _export = _docsFor == 'dart' ? 'publicly declare' : 'export';
- var _declare = _docsFor == 'dart' ? 'declare' : 'export';
:marked
  The key take-aways are:
  * Angular apps are composed of modules.
  * Modules !{_export} things &mdash; classes, function, values &mdash; that other modules import.
  * We prefer to write our application as a collection of modules, each module exporting one thing.
  
  Las ideas clave que debemos aprender son:
  * Las aplicaciones de Angular están compuestas de módulos.
  * Los módulos !{_exportan} cosas &mdash; clases, funciones, valores &mdash; que otros módulos importan.
  * Es preferible hacer nuestras aplicaciones como colecciones de módulos, cada módulo exporta una cosa.

  The first module we write will most likely !{_declare} a component.
  
  El primer módulo que probablemente haremos !{_declarará} un componente.

.l-main-section
:marked
  ## Components
  
  ## Componentes
figure
  img(src="/resources/images/devguide/architecture/hero-component.png" alt="Component" align="left" style="width:200px; margin-left:-40px;margin-right:10px" )

:marked
  A **component** controls a patch of screen real estate that we could call a *view*.
  The shell at the application root with navigation links, a list of heroes, a hero editor ...
  they're all views controlled by components.
  
  Un **componente ** controla una parte de la pantalla que podríamos llamar *vista*. 
  la vista del componente raíz con los enlaces de navegación, una lista de héroes, un editor de héroe ...
  todas son vistas controladas por componentes.

  We define a component's application logic &mdash; what it does to support the view &mdash; inside a class.
  The class interacts with the view through an API of properties and methods.
  
  Definimos la lógica de aplicación de un componente &mdash; lo que hace para dar vida a la vista; dentro de una clase.
  La clase interactúa con la vista mediante una API de propiedades y métodos.

  <a id="component-code"></a>
  A `HeroListComponent`, for example, might have a `heroes` property that returns !{_an} !{_array} of heroes
  that it acquired from a service.
  It might have a `selectHero()` method that sets a `selectedHero` property when the user clicks to choose a hero from that list.
  The component might be a class like this:
  
  Un componente llamado `HeroListComponent`, por ejemplo; podría tener una propiedad `heroes` que regresa !{_un} !{arreglo} de héroes
  que consiguió de un servicio.
  Podría tener un método `selectHero()` que asigna una propiedad `selectedHero` cuando el usuario da click para escoger un héroe de la lista.
  El componente podría ser una clase como esta:

+makeExcerpt('app/hero-list.component.ts', 'class')
:marked
  Angular creates, updates, and destroys components as the user moves through the application.
  The developer can take action at each moment in this lifecycle through optional [lifecycle hooks](lifecycle-hooks.html), like `ngOnInit()` declared above.
  
  Angular crea, actualiza y destruye componentes mientras el usuario navega a través de la aplicación.
  El desarrollador puede tomar una acción en cada momento de este ciclo de vida por medio de [lifecycle hooks](lifecycle-hooks.html) opcionales, como `ngOnInit()` declarado en el ejemlo anterior.
.l-sub-section
  :marked
    We may wonder who is calling the component's constructor? Who provides the service parameter?
    For the moment, have faith that Angular will call the constructor and deliver an
    appropriate `HeroService` when we need it.
    
    Nos podemos preguntar ¿Quién llama al constructor del componente? ¿Quién proporciona el parámetro del servicio?
    Por el momento, tenga confianza de que Angular llamará al constructor y que entragará el servicio `HeroService` apropiado cuando lo necesitemos.

.l-main-section
:marked
  ## Templates
  
  ## Plantillas
figure
  img(src="/resources/images/devguide/architecture/template.png" alt="Template" align="left" style="width:200px; margin-left:-40px;margin-right:10px" )
:marked
  We define a component's view with its companion **template**. A template is a form of HTML
  that tells Angular how to render the component.
  
  Definimos la vista de un componente con una **plantilla** que lo acompaña. Una plantilla es una forma de HTML
  que le dice a Angular como desplegar el componente.

  A template looks like regular HTML much of the time ... and then it gets a bit strange. Here is a
  template for our `HeroListComponent`:
  
  Una plantilla se ve como HTML regular la mayor parte del tiempo y luego ... se pone un poco extraño. Aquí está una 
  plantilla para nuestro componente `HeroListComponent`:

+makeExample('app/hero-list.component.html')

:marked
  This template features typical HTML elements like `<h2>` and  `<p>`.
  But what are `*ngFor`, `{{hero.name}}`, `(click)`, `[hero]`, and `<hero-detail>`?
  
  Esta plantilla tiene elementos típicos de HTML como `<h2>` y  `<p>`.
  Pero ¿Qué son `*ngFor`, `{{hero.name}}`, `(click)`, `[hero]`, y `<hero-detail>`?

  These are examples of Angular's [template syntax](template-syntax.html).
  We will grow accustomed to that syntax and may even learn to love it.
  We'll begin to explain it in a moment.
  
  Estos son ejemplos de la [template syntax](template-syntax.html) de Angular.
  Nos iremos acostumbrando a esta sintaxis y tal vez incluso aprenderemos a amarla.
  Comenzaremos a explicarla en un momento.

  Before we do, focus attention on the last line.
  The `<hero-detail>` tag is a custom element representing the `HeroDetailComponent`.
  
  Antes de hacerlo, pon atención en la última línea.
  El tag `<hero-detail>` es un elemento personalizado que representa el componente `HeroDetailComponent`.

  The `HeroDetailComponent` is a *different* component than the `HeroListComponent` we've been reviewing.
  The `HeroDetailComponent` (code not shown) presents facts about a particular hero, the
  hero that the user selects from the list presented by the `HeroListComponent`.
  The `HeroDetailComponent` is a **child** of the `HeroListComponent`.
  
  El componente `HeroDetailComponent` es un componente *diferente* al componente `HeroListComponent` que hemos repasado.
  El componente `HeroDetailComponent` (no se muestra el código) muestra datos de un héroe en particular, el
  héroe que el usuario selecciona de la lista presentada por el componente `HeroListComponent`.
  El componente `HeroDetailComponent` es un componente **hijo** del componente `HeroListComponent`.

figure
  img(src="/resources/images/devguide/architecture/component-tree.png" alt="Metadata" align="left" style="width:300px; margin-left:-40px;margin-right:10px" )
:marked
  Notice how `<hero-detail>` rests comfortably among native HTML elements.
  We can and _will_ mix our custom components with native HTML in the same layouts.
  
  Note como `<hero-detail>` está entre los elementos nativos de HTML cómodamente.
  Podemos y _mezclaremos_ nuestros componentes personalizados con los nativos de HTML en las mismas vistas.

  In this manner we'll compose complex component trees to build out our richly featured application.
  
  De esta manera compondremos árboles de componentes complejos para construir nuestra aplicación rica en funcionalidad. 
<br clear="all">

.l-main-section
:marked
  ## Metadata
  
  ## Metadatos
figure
  img(src="/resources/images/devguide/architecture/metadata.png" alt="Metadata" align="left" style="width:150px; margin-left:-40px;margin-right:10px" )

:marked
<p style="padding-top:10px">Metadata tells Angular how to process a class.</p>
<br clear="all">
:marked
  [Looking back at the code](#component-code) for `HeroListComponent`, we see that it's just a class.
  There is no evidence of a framework, no "Angular" in it at all.
  
  [Si vemos nuevamente el código](#component-code) del componente `HeroListComponent`, vemos que es sólo una clase.
  No hay evidencia de un framework, no hay nada de "Angular" en ella.

  In fact, it really is *just a class*. It's not a component until we *tell Angular about it*.
  
  De hecho, en realidad es *sólo una clase*. No es un componente hasta que *se lo digamos a Angular*. 

  We tell Angular that `HeroListComponent` is a component by attaching **metadata** to the class.
  
  Le decimos a Angular que `HeroListComponent` es un componente al agregar **metadatos** a la clase. 

  In !{_Lang}, we attach metadata by using !{_a} **!{_decorator}**.
  Here's some metadata for `HeroListComponent`:
  
  En!{_Lang}, agregamos metadatos usando !{_un} **!{_decorador}**.
  Aquí hay un ejemplo de metadato para el componente `HeroListComponent`:

+makeExcerpt('app/hero-list.component.ts', 'metadata')

:marked
  Here we see the `@Component` !{_decorator} which (no surprise) identifies the class
  immediately below it as a component class.
  
  Aquí vemos el !{_decorador} `@Component`, el cual identifica la clase
  como una clase de componente.

block ts-decorator
  :marked
    A decorator is a function. Decorators often have a configuration parameter.
    The `@Component` decorator takes a required configuration object with the
    information Angular needs to create and present the component and its view.
    
    Un decorador es una función. Los decoradores a menudo tienen un parámetro de configuración.
    El decorador `@Component` lleva un objeto de configuración requerido con la
    información que Angular necesita para crear y presentar el componente y su vista.

    Here are a few of the possible `@Component` configuration options:
    
    Aquí hay algunas de las posibles opciones de configuración del `@Component`:

:marked
  - `selector`: CSS selector that tells Angular to create and insert an instance of this component
  where it finds a `<hero-list>` tag in *parent* HTML.
  For example, if an app's  HTML contains `<hero-list></hero-list>`, then
  Angular inserts an instance of the `HeroListComponent` view between those tags.
  
  - `selector`: selector CSS que le dice a Angular que cree e inserte una instancia de este componente
  en donde encuentre un tag `<hero-list>` en un HTML *padre*.
  Por ejemplo, si un HTML de la aplicación contiene `<hero-list></hero-list>`, entonces
  Angular insertará uns instancia de la vista del componente `HeroListComponent` entre esos tags. 

  - `templateUrl`: address of this component's template, which we showed [above](#templates).
  
  - `templateUrl`: dirección de la plantilla de este componente, el cual mostramos [arriva](#templates).

  - `directives`: !{_array} of the components or directives that *this* template requires.
  We saw in the last line of our template that we expect Angular to insert a `HeroDetailComponent`
  in the space indicated by `<hero-detail>` tags.
  Angular will do so only if we mention the `HeroDetailComponent` in this `directives` !{_array}.
  
  - `directives`: !{_arreglo} de los componentes o las directivas que *esta* plantilla requiere.
  Vimos en la última línea de nuestra plantilla que esperamos que Angular inserte un componente `HeroDetailComponent`
  en el espacio indicado por los tags `<hero-detail>`.
  Angular lo hará sólo si lo mencionamos en este !{_arreglo} de `directives` en el componente `HeroDetailComponent`.

  - `providers`: !{_array} of **dependency injection providers** for services that the component requires.
  This is one way to tell Angular that our component's constructor requires a `HeroService`
  so it can get the list of heroes to display. We'll get to dependency injection later.
  
  - `providers`: !{_arreglo} de **dependency injection providers** para servicios que requiere el componente.
  Esta es una manera de decir a Angular que el constructor de nuestro componente requiere un servicio `HeroService`
  para poder obtener la lista de héroes que desplegará. Ya veremos la inyección de dependencias después.

figure
  img(src="/resources/images/devguide/architecture/template-metadata-component.png" alt="Metadata" align="left" style="height:200px; margin-left:-40px;margin-right:10px" )

:marked
  Angular reads the metadata specified by the `@Component`
  annotation. That's how Angular learns to do "the right thing".
  
  Angular lee los metadatos especificados por la anotación 
  `@Component`. Así es como Angular aprende a hacer "lo correcto". 

  The template, metadata, and component together describe a view.
  
  La plantilla, los metadatos y el componente en conjunto describen una vista.

  We apply other metadata !{_decorator}s in a similar fashion to guide Angular behavior.
  `@Injectable`, `@Input`, and `@Output` are a few of the more popular !{_decorator}s
  we'll master as our Angular knowledge grows.
  
  Aplicamos otros metadatos !{_decorador}es de forma similar, para guiar el comportamiento de Angular.
  `@Injectable`, `@Input`, y `@Output` son algunos de los !{_decorador}es más populares 
  que dominaremos mientras nuestro conocimiento de Angular crece.
<br clear="all">
:marked
  The architectural takeaway is that we must add metadata to our code
  so that Angular knows what to do.
  
  Lo que debemos recordar en cuestión de arquitectura es que debemos agregar metadatos a nuestro código
  para que Angular sepa que hacer.

.l-main-section
:marked
  ## Data binding
  Without a framework, we would be responsible for pushing data values into the HTML controls and turning user responses
  into actions and value updates. Writing such push/pull logic by hand is tedious, error-prone, and a nightmare to
  read as any experienced jQuery programmer can attest.
  
  ## Data binding
  Sin un framework, nosotros seríamos los responsables de empujar los valores de los datos en los controles del HTML y de convertir la respuesta del usuario
  en acciones y actualizaciones de los de los valors. Escribir dicha lógica de push/pull a mano es tedioso, propenso a errores y una pesadilla
  de leer, como cualquier programado de jQuery experimentado puede atestar.
figure
  img(src="/resources/images/devguide/architecture/databinding.png" alt="Data Binding" style="width:220px; float:left; margin-left:-40px;margin-right:20px" )
:marked
  Angular supports **data binding**,
  a mechanism for coordinating parts of a template with parts of a component.
  We add binding markup to the template HTML to tell Angular how to connect both sides.

  Angular soporta **data binding**,
  un mecanismo para coordinar partes de la plantilla  con partes del componente.
  Agregamos código binding a la plantilla HTML para decirle a Angular como conectar ambos lados. 
  
  There are four forms of data binding syntax. Each form has a direction &mdash; to the DOM, from the DOM, or in both directions &mdash;
  as indicated by the arrows in the diagram.
  
  Hay cuatro formas de sintaxis de data binding. Cada forma tiene un dirección &mdash; hacia el DOM, desde el DOM o en ambas direcciónes;
  como lo indican las flechas en el diagrama.
<br clear="all">
:marked
  We saw three forms of data binding in our [example](#templates) template:
  
  Vimos tres formas de data binding en la plantilla de nuestro ejemplo](#templates):

+makeExcerpt('app/hero-list.component.1.html', 'binding')

:marked
  * The `{{hero.name}}` [*interpolation*](displaying-data.html#interpolation)
  displays the component's `hero.name` property value within the `<li>` tags.
  
  * La [*interpolación*](displaying-data.html#interpolation) `{{hero.name}}`
  despliega el valor de la propiedad `hero.name` del componente entre los tags `<li>`.

  * The `[hero]` [*property binding*](template-syntax.html#property-binding) passes the value of `selectedHero` from
  the parent `HeroListComponent` to the `hero` property of the child `HeroDetailComponent`.
  
  * El [*binding de la propiedad*](template-syntax.html#property-binding) `[hero]` pasa el valor del `selectedHero` del
  componente padre `HeroListComponent` a la propiedad `hero` del componente hijo `HeroDetailComponent`.

  * The `(click)` [*event binding*](user-input.html#click) calls the component's `selectHero` method when the user clicks a hero's name.
  
  * El [*binding de evento*](user-input.html#click) `(click)` llama el método `selectHero` del componente cuando el usuario da click en el nombre de un héroe.

  **Two-way data binding** is an important fourth form
  that combines property and event binding in a single notation, using the `ngModel` directive.
  We didn't have a two-way binding in the `HeroListComponent` template;
  here's an example from the `HeroDetailComponent` template:
  
  **Two-way data binding** es una cuarta forma importante
  que combina el binding de propiedad y el binding de evento en una sola notación, usando la directiva `ngModel`.
  No teníamos un two-way binding en la plantilla `HeroListComponent`;
  aquí hay un ejemplo de la plantilla del componente `HeroDetailComponent`:

+makeExcerpt('app/hero-detail.component.html', 'ngModel')

:marked
  In two-way binding, a data property value flows to the input box from the component as with property binding.
  The user's changes also flow back to the component, resetting the property to the latest value,
  as with event binding.
  
  En el two-way binding, el valor de una propiedad fluye al input box del componente con el binding de la propiedad.
  Los cambios del usuario fluyen de vuelta al componente, restableciendo la propiedad al último valor,
  con el binding de evento.

  Angular processes *all* data bindings once per JavaScript event cycle,
  from the root of the application component tree down to the leaves.
  
  Angular procesa *todos* los data bindings una vez por ciclo de evento de JavaScript,
  del componente raíz del árbol de componentes de la aplicación hacia abajo.

figure
  img(src="/resources/images/devguide/architecture/component-databinding.png" alt="Data Binding" style="float:left; width:300px; margin-left:-40px;margin-right:10px" )
:marked
  We don't know all the details yet,
  but it's clear from these examples that data binding plays an important role in communication
  between a template and its component.
  
  Todavía no conocemos todos los detalles,
  pero queda claro con este ejemplo que el data binding juega un papel importante en la comunicación
  entre una plantilla y su componente.
<br clear="all">
figure
  img(src="/resources/images/devguide/architecture/parent-child-binding.png" alt="Parent/Child binding" style="float:left; width:300px; margin-left:-40px;margin-right:10px" )
:marked
  Data binding is also important for communication between parent and child components.
  
  El data binding es importante también en la comunicación entre componentes padre e hijo.
<br clear="all">

.l-main-section
:marked
  ## Directives
  
  ## Directivas
figure
  img(src="/resources/images/devguide/architecture/directive.png" alt="Parent child" style="float:left; width:150px; margin-left:-40px;margin-right:10px" )
:marked
  Angular templates are *dynamic*. When Angular renders them, it transforms the DOM
  according to the instructions given by **directives**.
  
  Las plantillas de Angular son *dinámicas*. Cuando angular las despliega, transforma el DOM
  conforme a las instrucciones dadas por las **directivas**.  

  A directive is a class with directive metadata. In !{_Lang} we apply the `@Directive` !{_decorator}
  to attach metadata to the class.
  
  Una directiva es una clase con metadatos de directiva. En !{_Lang} aplicamos el !{_decorador} `@Directive`
  para agregar metadatos a la clase.
<br clear="all">
:marked
  We already met one form of directive: the component. A component is a *directive-with-a-template*;
  a `@Component` !{_decorator} is actually a `@Directive` !{_decorator} extended with template-oriented features.
  
  Ya conocimos una forma de directiva: el componente. Un componente es una *directiva-con-una-plantilla*;
  un !{_decorador} `@Component` es en realidad un !{_decorador} `@Directive` extendido con funcionalidades orientadas a una plantilla.

.l-sub-section
  :marked
    While **a component is technically a directive**,
    components are so distinctive and central to Angular applications that we chose
    to separate components from directives in this architectural overview.
    
    Aunque **un componente es técnicamente una directiva**,
    los componentes son tan diferentes y centrales a las aplicaciones de Angular que decidimos
    separar los componentes de las directivas en esta vista general de arquitectura.
:marked
  Two *other* kinds of directives exist: _structural_ and _attribute_ directives.
  
  Existen *otros* dos tipos de directivas: directivas _estructurales_ y de _atributo_.

  They tend to appear within an element tag as attributes do,
  sometimes by name but more often as the target of an assignment or a binding.
  
  Tienden a aparecer entre el tag de un elemento como lo hacen los atributos,
  algunas veces por nombre, pero más a menudo como asignación o un binding.

  **Structural** directives alter layout by adding, removing, and replacing elements in DOM.
  
  Las directivas **estructurales** alteran la plantilla al agregar, remover y reemplazar elementos en el DOM.

  Our [example](#templates) template uses two built-in structural directives:
  
  Nuestro [ejemplo](#templates) de plantilla usa dos directivas estructurales incluidas en Angular:

+makeExcerpt('app/hero-list.component.1.html', 'structural')

:marked
  * [`*ngFor`](displaying-data.html#ngFor) tells Angular to stamp out one `<li>` per hero in the `heroes` list.
  * [`*ngIf`](displaying-data.html#ngIf) includes the `HeroDetail` component only if a selected hero exists.
  
  * [`*ngFor`](displaying-data.html#ngFor) le dice a Angular que pinte un `<li>` por héroe en la lista `heroes`.
  * [`*ngIf`](displaying-data.html#ngIf) incluye el componente `HeroDetail` solo si existe un héroe seleccionado.

block dart-bool
  //- N/A

:marked
  **Attribute** directives alter the appearance or behavior of an existing element.
  In templates they look like regular HTML attributes, hence the name.
  
  Las directivas de **atributo** alteran la apariencia o comportamiento de un elemento existente.
  En plantillas, estas directivas se ven como atributos regular de HTML, por eso el nombre.

  The `ngModel` directive, which implements two-way data binding, is
  an example of an attribute directive. `ngModel` modifies the behavior of
  an existing element (typically an `<input>`)
  by setting its display value property and responding to change events.
  
  La directiva `ngModel`, la cual implemente el two-way data binding, es
  un ejemplo de una directiva de atributo. `ngModel` modifica el comportamiento de
  un elemento existente (típicamente un `<input>`)
  al poner el valor que despliega y al responder a eventos que lo cambien.

+makeExcerpt('app/hero-detail.component.html', 'ngModel')
:marked
  Angular ships with a small number of other directives that either alter the layout structure
  (for example, [ngSwitch](template-syntax.html#ngSwitch))
  or modify aspects of DOM elements and components
  (for example, [ngStyle](template-syntax.html#ngStyle) and [ngClass](template-syntax.html#ngClass)).
  
  Angular incluye un número pequeño de otras directivas que ya sea que altere la estructura de la plantilla
  (por ejemplo, [ngSwitch](template-syntax.html#ngSwitch))
  o que modifique el aspecto de los elementos del DOM y de componentes
  (por ejemplo, [ngStyle](template-syntax.html#ngStyle) y [ngClass](template-syntax.html#ngClass)).

  Of course, we can also write our own directives. Components such as
  `HeroListComponent` are one kind of custom directive.
  <!-- PENDING: link to where to learn more about other kinds! -->

  Po supuesto, también podemos escribir nuestras propias directivas. Componentes como
  `HeroListComponent` son un tipo de directivas personalizadas.
  <!-- PENDING: link a donde aprender más acerca de otros tipos! -->
.l-main-section
:marked
  ## Services
  
  ## Servicios
figure
  img(src="/resources/images/devguide/architecture/service.png" alt="Service" style="float:left; margin-left:-40px;margin-right:10px" )
:marked
  _Service_ is a broad category encompassing any value, function, or feature that our application needs.

  El _servicio_es una categoría extensa que abarca cualquier valor, función o funcionalidad que nuestra aplicación necesite.
  
  Almost anything can be a service.
  A service is typically a class with a narrow, well-defined purpose. It should do something specific and do it well.
  
  Casi cualquier cosa puede ser un servicio.
  Un servicio es generalmente una clase con un propósito corto y bien definido. Debe hacer algo específico y hacerlo bien.
<br clear="all">
:marked
  Examples include:
  * logging service
  * data service
  * message bus
  * tax calculator
  * application configuration
  
  Algunos ejemplos incluyen:
  * servicio de loggin
  * servicio de datos
  * autobús de datos
  * calculadora de impuestos
  * configuración de aplicación

  There is nothing specifically _Angular_ about services. Angular itself has no definition of a service.
  There is no service base class, and no place to register a service.
  
  En Angular no hay nada específico sobre un servicio; ni su definición; ni una clase base; ni un lugar donde registrarlo.
  
  Yet services are fundamental to any Angular application. Our components are big consumers of services.
  
  A pesar de todo, los servicios son fundamentales para cualquier aplicación de Angular. Nuestros componentes son grandes consumidores de servicios.

  Here's an example of a service class that logs to the browser console
  
  Aquí está un ejemplo de una clase de un servicio que escribe a la consola del navegador

+makeExcerpt('app/logger.service.ts', 'class')

:marked
  Here's a `HeroService` that fetches heroes and returns them in a resolved !{_PromiseLinked}.
  The `HeroService` depends on the `Logger` service and another `BackendService` that handles the server communication grunt work.
  
  Aquí está un servicio `HeroService` que trae héroes y los regresa en una !{_PromiseLinked} resuelta.
  El servicio `HeroService` depende del servicio `Logger` y de otro servicio `BackendService` que maneja el trabajo grunt de comunicación del servidor.

+makeExcerpt('app/hero.service.ts', 'class')

:marked
  Services are everywhere.
  
  Los servicios están en todos lados.

  We prefer our component classes lean. Our components don't fetch data from the server,
  they don't validate user input, and they don't log directly to the console.
  They delegate such tasks to services.
  
  Es preferible que nuestrios componentes se apoyen en servicios. Nuestros componentes no traen datos del servidor.
  No validan el input del usuario, y no despliegan mensajes directamente a la consola.
  Ellos delegan esas tareas a los servicios.

  A component's job is to enable the user experience and nothing more. It mediates between the view (rendered by the template)
  and the application logic (which often includes some notion of a _model_).
  A good component presents properties and methods for data binding.
  It delegates everything nontrivial to services.
  
  El trabajo de un componente es habilitar la experiencia del usuario y nada más. Es el mediador entre la vista (desplegada por la plantilla)
  y la lógica de la aplicación (la cual a menudo incluye alguna noción de un _modelo_).
  Un buen componente presenta propiedades y métodos para data binding.
  Delega todo lo no trivial a los servicios.

  Angular doesn't *enforce* these principles.
  It won't complain if we write a "kitchen sink" component with 3000 lines.
  
  Angular no *impone* estos principios.
  No se quejará si escribimos un componente "fregadero de cocina" con 300 líneas. 

  Angular does help us *follow* these principles by making it easy to factor our
  application logic into services and make those services available to components through *dependency injection*.
  
  Angular nos ayuda a *seguir* estos principios al facilitar la factorización de nuestra
  lógica de aplicación en servicios y hacer que esos servicios esten disponibles para los componentes a través de la *inyección de dependencias*.

.l-main-section
:marked
  ## Dependency injection
  
  ## Inyección de Dependencias
figure
  img(src="/resources/images/devguide/architecture/dependency-injection.png" alt="Service" style="float:left; width:200px; margin-left:-40px;margin-right:10px" )
:marked
  _Dependency injection_ is a way to supply a new instance of a class
  with the fully-formed dependencies it requires. Most dependencies are services.
  Angular uses dependency injection to provide new components with the services they need.
  
  La _Inyección de Dependencias_ es una manera de proporcionar una nueva instancia de una clase
  con todas las dependencias que ésta requiere. La mayoría de las dependencias son servicios.
  Angular usa la inyección de dependencias para proveer nuevos componentes con los servicios que éstos necesitan.
<br clear="all">
:marked
  Angular can tell which services a component needs by looking at the types of its constructor parameters.
  For example, the constructor of our `HeroListComponent` needs a `HeroService`:
  
  Angular sabe que servicios necesita un componente al mirar los tipos de los parámetros de su constructor.
  Por ejemplo, el constructor de nuestro componente `HeroListComponent` necesita un servicio `HeroService`:

+makeExcerpt('app/hero-list.component.ts (constructor)', 'ctor')

:marked
  When Angular creates a component, it first asks an **injector** for
  the services that the component requires.
  
  Cuando Angular crea un componente, primero pregunta a un **injector** por 
  los servicios que requiere dicho componente.

  An injector maintains a container of service instances that it has previously created.
  If a requested service instance is not in the container, the injector makes one and adds it to the container
  before returning the service to Angular.
  When all requested services have been resolved and returned,
  Angular can call the component's constructor with those services as arguments.
  This is what we mean by *dependency injection*.
  
  Un injector mantiene un contenedor de la instancia de un servicio que se ha creado previamente.
  Si una instancia de servicio requerida no está en el contenedor, el injector hace una y la agrega al contenedor
  Cuando todos los servicios requeridos han sido resueltos y regresados,
  Angular puede llamar el constructor del componente con esos servicios como argumentos.
  Esto es lo que queremos decir con *inyección de dependencias*

  The process of `HeroService` injection looks a bit like this:
  
  El proceso de inyección del servicio `HeroService` se ve parecido a esto:
figure
  img(src="/resources/images/devguide/architecture/injector-injects.png" alt="Service" )
:marked
  If the injector doesn't have a `HeroService`, how does it know how to make one?
  
  Si el injector no tiene un servicio `HeroService`, ¿cómo sabe hacer uno?

  In brief, we must have previously registered a **provider** of the `HeroService` with the injector.
  A provider is something that can create or return a service, typically the service class itself.
  
  En pocas palabras, debemos haber registrado previamente un **provider** del servicio `HeroService` con el injector. 
  Un provider es algo que puede crear o regresar un servicio, típicamente la clase misma del servicio.

  We can register providers at any level of the application component tree.
  We often do so at the root when we bootstrap the application so that
  the same instance of a service is available everywhere.
  
  Podemos registrar providers en cualquier nivel del árbol de componentes de la aplicación.
  A menudo lo hacemos en la raíz cuando hacemos el bootstrap de la aplicación, de modo que
  la misma instancia de un servicio esté disponible donde sea.
  
+makeExcerpt('app/main.ts', 'bootstrap')

:marked
  Alternatively, we might register at a component level, in the providers property of the `@Component` metadata:
  
  De manera alternativa, podríamos registrar al nivel de un componente en la propiedad providers del metadato `@Component`:

+makeExcerpt('app/hero-list.component.ts', 'providers')

:marked
  Registering at a component level means we get a new instance of the
  service with each new instance of that component.
  
  Registrarlo al nivel de un componente significa que obtendremos una instancia del
  servicio con cada nueva instancia de ese componente.

  <!-- We've vastly oversimplified dependency injection for this overview.
  The full story is in the [Dependency Injection](dependency-injection.html) chapter. -->
  
  <!-- Hemos simplicado demás la inyección de dependencias para este overview.
  La historia completa está en [Dependency Injection](dependency-injection.html) chapter. -->

  Points to remember about dependency injection:
  
  Puntos a recordar acerca de la inyección de dependencias:

  * Dependency injection is wired into the Angular framework and used everywhere.
  
  * La inyección de dependencias está cableada en el framework Angular y usada en todos lados.

  * The *injector* is the main mechanism.
    * An injector maintains a *container* of service instances that it created.
    * An injector can create a new service instance from a *provider*.
    
  * El *injector* es el mecanismo principal.
    * Un injector mantiene un *contenedor* de las instancias de los servicios que creó.
    * Un injector puede crear una nueva instancia de un servicio de un *provider*.

  * A *provider* is a recipe for creating a service.
  
  * Un *provider* es una receta para crear un servicio.

  * We register *providers* with injectors.
  
  * Registramos *providers* con injectors.

.l-main-section
:marked
  ## Wrap up
  
  ## Calentamiento

  We've learned just a bit about the eight main building blocks of an Angular application:
  
  Hemos aprendido sólo un poco acerca de los ocho bloques principales de una aplicación de Angular:

  1. [Modules](#modules)
  1. [Components](#components)
  1. [Templates](#templates)
  1. [Metadata](#metadata)
  1. [Data binding](#data-binding)
  1. [Directives](#directives)
  1. [Services](#services)
  1. [Dependency injection](#dependency-injection)
  
  1. [Módulos](#modules)
  1. [Componentes](#components)
  1. [Plantillas](#templates)
  1. [Metadatos](#metadata)
  1. [Data binding](#data-binding)
  1. [Directivas](#directives)
  1. [Servicios](#services)
  1. [Inyección de Dependencias](#dependency-injection)

  That's a foundation for everything else in an Angular application,
  and it's more than enough to get going.
  But it doesn't include everything we'll need or want to know.
  
  Estos son el fundamento para todo lo demás en una aplicación de Angular 
  y es más que suficiente para ponerse en marcha.
  Pero esto no incluye todo lo que necesitamos o queremos aprender.

  Here is a brief, alphabetical list of other important Angular features and services.
  Most of them are covered in this Developers Guide (or soon will be).

  Aquí está una breve lista alfabética de otras funcionalidades importantes de Angular y servicios.
  La mayoría de ellos son cubiertos en esta Guía del desarrollador (o pronto lo estará). 
  
  > [**Animations**](animations.html): The animation library makes it easy for developers to animate component behavior
  without deep knowledge of animation techniques or CSS.
  
  > [**Animaciones**](animations.html): La librería de animaciones hace que sea fácil para los desarrolladores poder animar el comportamiento de los componentes
  sin un conocimiento profundo de técnicas de animaciones o CSS.

  > **Bootstrap**: A method to configure and launch the root application component.
  
  > **Bootstrap**: Un método para configurar y lanzar el componente raíz de la aplicación.

  > **Change detection**: Learn how Angular decides that a component property value has changed and
  when to update the screen.
  Learn how it uses **zones** to intercept asynchronous activity and run its change detection strategies.
  
  > **Detección de cambios**: Aprende cómo Angular decide que el valor de una propiedad de un componente ha cambiado y
  cuándo actualizarlo en la pantalla.

  > **Component router**: With the component Router service, users can navigate a multi-screen application
  in a familiar web browsing style using URLs.
  
  > **Enrutador de Componente**: Con el servicio de enrutador de componente, los usuarios pueden navegar una aplicación multi pantalla 
  de un estilo de navegación usando URLs de forma familiar.  

  > **Events**: The DOM raises events. So can components and services. Angular offers mechanisms for
  publishing and subscribing to events.
  
  > **Eventos**: El DOM levanta eventos. De igual manera lo hacen los componentes y servicios. Angular ofrece un mecanismo para 
  publicar y suscribirse a eventos.

  > [**Forms**](forms.html): Support complex data entry scenarios with HTML-based validation and dirty checking.

  > [**Formularios**](forms.html): Soporta escenarios complejos de entrada con validaciones basadas en HTML y dirty checking.
  
  > [**HTTP**](server-communication.html): Communicate with a server to get data, save data, and invoke server-side actions with an HTTP client.

  > [**HTTP**](server-communication.html): Comunícate con el servidor para obtener datos, guarda datos e invoca acciones del lado del servidor con un cliente HTTP.
  
  > [**Lifecycle hooks**](lifecycle-hooks.html): We can tap into key moments in the lifetime of a component, from its creation to its destruction,
  by implementing the lifecycle hook interfaces.
  
  > [**Lifecycle hooks**](lifecycle-hooks.html): Podemos aprovechar los momentos clave en el ciclo de vida de un componente, desde su creación hasta su destrucción, 
  al implementar las interfaces de lifecycle hook.

  > [**Pipes**](pipes.html): Services that transform values for display.
  We can put pipes in our templates to improve the user experience. Consider
  this `currency` pipe expression:
  
  > [**Pipes**](pipes.html): Servicios que transforman los valores a desplegar.
  Podemos poner pipes en nuestras plantillas para mejorar la experiencia del usuario. Considereé
  esta expresión de pipe `currency`:
<div style="margin-left:40px">
code-example().
  price | currency:'USD':true
</div>
:marked
  > It displays a price of "42.33" as `$42.33`.
  
  > Despliega un precio de "42.33" como `$42.33`.

  > [**Router**](router.html): Navigate from page to page within the client
    application and never leave the browser.
    
  > [**Enrutador**](router.html): Navega de página en página con la aplicación de cliente y nunca dejes el navegador.  

  > [**Testing**](testing.html): Angular provides a
  [testing library](https://pub.dartlang.org/packages/angular2_testing)
  to run unit tests on our application parts as they interact with the Angular framework.
  
  > [**Testing**](testing.html): Angular provee una [librería de pruebas](https://pub.dartlang.org/packages/angular2_testing)
  para correr pruebas unitarias en las partes de nuestra aplicación mientras interactúan con el framework Angular.
