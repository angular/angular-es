block includes
  include ../_util-fns

- var top="vertical-align:top"

:marked
  # Component Lifecycle
  A Component has a lifecycle managed by Angular itself. Angular creates it, renders it, creates and renders its children,
  checks it when its data-bound properties change, and destroys it before removing it from the DOM.
  
  # Ciclo de vida del componente 
  Un componente tiene un ciclo de vida manejado por el mismo Angular. Angular lo crea, lo presenta, crea y presenta su hijo,
  comprueba que cuando esté enlazado a datos sus propiedades cambien, y lo destruye antes de quitarlo del DOM.

  Angular offers **component lifecycle hooks**
  that give us visibility into these key moments and the ability to act when they occur.
  
  Angular ofrece **hooks del ciclo de vida del componente**
  que brindan visibilidad en esos momentos clave y la capacidad de actuar cuando ocurren.

  We cover these hooks in this chapter and demonstrate how they work in code.
  
  Se cubren estos hooks en este capítulo y se demuestra como funcionan en código.

  * [The lifecycle hooks](#hooks-overview)
  * [The hook-call sequence](#hook-sequence)
  * [Other Angular lifecycle hooks](#other-lifecycles)
  * [The lifecycle sample](#the-sample)
    * [All](#peek-a-boo)
    * [Spying OnInit and OnDestroy](#spy)
    * [OnChanges](#onchanges)
    * [DoCheck](#docheck)
    * [AfterViewInit and AfterViewChecked](#afterview)
    * [AfterContentInit and AfterContentChecked](#aftercontent)
    
  * [Los hooks de ciclo de vida](#hooks-overview)
    * [La secuencia de llamadas hook](#hook-sequence)
    * [Otros hooks de ciclo de vida de Angular](#other-lifecycles)
    * [El ejemplo de ciclo de vida](#the-sample)
      * [Todo](#peek-a-boo)
      * [Espiando OnInit y OnDestroy](#spy)
      * [OnChanges](#onchanges)
      * [DoCheck](#docheck)
      * [AfterViewInit y AfterViewChecked](#afterview)
      * [AfterContentInit y AfterContentChecked](#aftercontent)

  Try the <live-example></live-example>.
  
  Pruebe el <live-example></live-example>.

a#hooks-overview
.l-main-section
:marked
  ## Component lifecycle Hooks
  Directive and component instances have a lifecycle
  as Angular creates, updates, and destroys them.
  
  ## Hooks de ciclo de vida de componente
  Las instancias de directiva y componente tienen un ciclo de vida
  a medida que Angular las crea, actualiza y destruye.

  Developers can tap into key moments in that lifecycle by implementing
  one or more of the *Lifecycle Hook* interfaces in the Angular `core` library.
  
  Los desarrolladores pueden acceder a momentos clave en ese ciclo de vida implementando
  una o más de las interfaces de *Hooks de ciclo de vida* de la librería `core` de Angular.

  Each interface has a single hook method whose name is the interface name prefixed with `ng`.
  For example, the `OnInit` interface has a hook method named `ngOnInit`.
  We might implement it in a component class like this:
  
  Cada interfaz tiene un método hook simple del cual el nombre es el nombre de la interfaz con el prefijo `ng`.
  Por ejemplo, la interfaz `OnInit` tienen un método hook llamado `ngOnInit`.
+makeExample('lifecycle-hooks/ts/app/peek-a-boo.component.ts', 'ngOnInit', 'peek-a-boo.component.ts (excerpt)')(format='.')
:marked
  No directive or component will implement all of them and some of the hooks only make sense for components.
  Angular only calls a directive/component hook method *if it is defined*.
  
  Ninguna directiva o componente implementará todos ellos y algunos de los hooks solo tendrán sentido para componentes.
  Angular sólo llama un método hook de directiva/componente *si está definido*.

+ifDocsFor('ts|js')
  .l-sub-section
    :marked
      ### Interface optional?
      
      ### ¿Interfaz opcional?

      The interfaces are optional for JavaScript and Typescript developers from a purely technical perspective.
      The JavaScript language doesn't have interfaces.
      Angular can't see TypeScript interfaces at runtime because they disappear from the transpiled JavaScript.
      
      Las interfaces son opcionales para los desarrolladores de JavaScript y Typescript desde una perspectiva puramente técnica.
      El lenguaje JavaScript no tiene interfaces.
      Angular no puede ver las interfaces TypeScript en tiempo de ejecución porque desaparecen del JavaScript transpilado.

      Fortunately, they aren't necessary.
      We don't have to add the lifecycle hook interfaces to our directives and components to benefit from the hooks themselves.
      
      Afortunadamente, no son necesarias.
      No se tienen que agregar las interfaces de hook de ciclo de vida a las directivas y componentes para aprovechar los hooks por sí mismos.

      Angular instead inspects our directive and component classes and calls the hook methods *if they are defined*.
      Angular will find and call methods like `ngOnInit()`, with or without the interfaces.
      
      En su lugar Angular inspecciona las clases de componente y directiva y llama a los métodos hook *si están definidos*.
      Angular encontrará y llamará métodos como `ngOnInit()`, con o sin las interfaces.

      Nonetheless, we strongly recommend adding interfaces to TypeScript directive classes
      in order to benefit from strong typing and editor tooling.
      
      Sin embargo, se recomienda fuertemente agregar interfaces a las clases TypeScript de directiva 
      con el fin de aprovechar la utileria de tipos fuertes y el editor.

:marked
  Here are the component lifecycle hook methods:
  
  Aquí están los métodos hook de ciclo de vida:

  ### Directives and Components
  
  ### Directivas y componentes

table(width="100%")
  col(width="20%")
  col(width="80%")
  tr
    th Hook
    th Purpose
  tr(style=top)
    td ngOnInit
    td
      :marked
        Initialize the directive/component after Angular initializes the data-bound input properties.
        
        Inicializar la directiva/componente después de que Angular inicializa el enlace de datos de las propiedades de entrada.
  tr(style=top)
    td ngOnChanges
    td
      :marked
        Respond after Angular sets a data-bound input property.
        The method receives a `changes` object of current and previous values.
        
        Reaccionar después de que Angular establece en enlace de datos de las propiedades de entrada.
        El método recibe un objeto `changes` con los valores actuales y anteriores.
  tr(style=top)
    td ngDoCheck
    td
      :marked
        Detect and act upon changes that Angular can't or won't
        detect on its own. Called every change detection run.
        
        Detectar y actuar sobre los cambios que Angular no puede o no 
        detectará por sí mismo. Llamado cada vez que se ejecuta la detección de cambio.
  tr(style=top)
    td ngOnDestroy
    td
      :marked
        Cleanup just before Angular destroys the directive/component.
        Unsubscribe observables and detach event handlers to avoid memory leaks.
        
        Limpiar solo antes de que Angular destruya la directiva/componente.
        Desuscribir observables y cancelar manejadores de evento para evitar pérdidas de memoria.

:marked
  ### Components only
  
  ### Sólo componentes

table(width="100%")
  col(width="20%")
  col(width="80%")
  tr
    th Hook
    th Purpose
  tr(style=top)
    td ngAfterContentInit
    td
      :marked
        After Angular projects external content into its view.
        
        Después de que Angular proyecta contenido externo en su vista.
  tr(style=top)
    td ngAfterContentChecked
    td
      :marked
        After Angular checks the bindings of the external content that it projected into its view.
        
        Despupés de que Angular comprueba los enlaces del contenido externo que es proyectado en su vista.
  tr(style=top)
    td ngAfterViewInit
    td
      :marked
        After Angular creates the component's view(s).
        
        Después de que Angular crea la vista(s) de los componentes.
  tr(style=top)
    td ngAfterViewChecked
    td
      :marked
        After Angular checks the bindings of the component's view(s).
        
        Después de que Angular comprueba los enlaces de la vista(s) de los componentes.
:marked
  Angular does not call the hook methods in this order.
  
  Angular no llama a los métdos hook en este orden.

a(id="hook-sequence")
.l-main-section
:marked
  ## Lifecycle sequence
  *After* Angular creates a component/directive by `new`-ing its constructor,
  it calls the lifecycle hook methods in the following sequence at specific moments:
  
  ## Secuencia de ciclo de vida
  *Después* de que Angular crea un componente/directiva con su constructor `new`,
  llama a los métodos hook de ciclo de vida en la siguiente secuencia en los momentos especificados:
table(width="100%")
  col(width="20%")
  col(width="80%")
  tr
    th Hook
    th Timing
  tr(style=top)
    td ngOnChanges
    td
      :marked
        before `ngOnInit` and when a data-bound input property value changes.
        
        antes de `ngOnInit` y cuando un valor de un enlace de datos de propiedad de entrada cambia.
  tr(style=top)
    td ngOnInit
    td
      :marked
        after the first `ngOnChanges`.
        
        después del primer `ngOnChanges`.
  tr(style=top)
    td ngDoCheck
    td
      :marked
        during every Angular change detection cycle.
        
        durante cada ciclo de detección de cambio de Angular.
  tr(style=top)
    td ngAfterContentInit
    td
      :marked
        after projecting content into the component.
        
        después de proyectar contenido en el componente.
  tr(style=top)
    td ngAfterContentChecked
    td
      :marked
        after every check of projected component content.
       
        después de cada comprobación de contenido proyectado en el componente.
  tr(style=top)
    td ngAfterViewInit
    td
      :marked
        after initializing the component's views and child views.
        
        después de inicializar las vistas de los componentes y vistas hijas.
  tr(style=top)
    td ngAfterViewChecked
    td
      :marked
        after every check of the component's views and child views.
       
        después de cada comprobación de las vistas de los componentes y vistas hijas.
  tr(style=top)
    td ngOnDestroy
    td
      :marked
        just before Angular destroys the directive/component.
       
        solo antes de que Angular destruya la directiva/componente.

a(id="other-lifecycles")
.l-main-section
:marked
  ## Other lifecycle hooks
  
  ## Otros hooks de ciclo de vida

  Other Angular sub-systems may have their own lifecycle hooks apart from the component hooks we've listed.
  
  Otros subsistemas de Angular podrían tener sus propios hooks de ciclo de vida aparte de los hooks de componente listados.

block other-angular-subsystems
  //- N/A for TS.

:marked
  3rd party libraries might implement their hooks as well in order to give us, the developers, more
  control over how these libraries are used.
  
  Las librerías de terceros podrían implementar sus propios hooks también con el fin de brindar a los desarrolladores más
  control sobre cómo se utilizan esas librerías.

.l-main-section#the-sample
:marked
  ## Lifecycle exercises
  
  ## Ejercicios de ciclo de vida 

  The <live-example></live-example>
  demonstrates the lifecycle hooks in action through a series of exercises
  presented as components under the control of the root `AppComponent`.
  
  El <live-example></live-example>
  demuestra los hooks de ciclo de vida en acción a través de unas series de ejercicios
  presentadas como componentes bajo el control del componente raíz `AppComponent`.

  They follow a common pattern: a *parent* component serves as a test rig for
  a *child* component that illustrates one or more of the lifecycle hook methods.
  
  Siguen un patrón común: un componente *padre* sirve como un banco de prubas para
  el componente *hijo* que ilustra uno o más de los métodos hook de ciclo de vida.

  Here's a brief description of each exercise:
  
  Aquí está una breve descripción de cada ejercicio:

table(width="100%")
  col(width="20%")
  col(width="80%")
  tr
    th Component
    th Description
  tr(style=top)
    td <a href="#peek-a-boo">Peek-a-boo</a>
    td
      :marked
        Demonstrates every lifecycle hook.
        Each hook method writes to the on-screen log.
        
        Demuestra cada hook de ciclo de vida.
        Cada método hook escribe en el registro en pantalla.
  tr(style=top)
    td <a href="#spy">Spy</a>
    td
      :marked
        Directives have lifecycle hooks too.
        We create a `SpyDirective` that logs when the element it spies upon is
        created or destroyed using the `ngOnInit` and `ngOnDestroy` hooks.
        
        Las directivas tienen hooks de ciclo de vida también.
        Se crea una directiva `SpyDirective` que registra cuando el elemento que espía es
        creado o destruído utilizando los hooks `ngOnInit` y `ngOnDestroy`.

        We apply the `SpyDirective` to a `<div>` in an `ngFor` *hero* repeater
        managed by the parent `SpyComponent`.
        
        Se aplica la directiva `SpyDirective` a un `<div>` en un repetidor `ngFor` *héroe* 
        controlado por el componente padre `SpyComponent`.
  tr(style=top)
    td <a href="#onchanges">OnChanges</a>
    td
      :marked
        See how Angular calls the `ngOnChanges` hook with a `changes` object
        every time one of the component input properties changes.
        Shows how to interpret the `changes` object.
        
        Observe cómo Angular llama al hook `ngOnChanges` con un objeto `changes`
        cada vez que una de las propiedades de entrada del componente cambia.
  tr(style=top)
    td <a href="#docheck">DoCheck</a>
    td
      :marked
        Implements an `ngDoCheck` method with custom change detection.
        See how often Angular calls this hook and watch it post changes to a log.
        
        Implementa un método `ngDoCheck` con un método personalizado de detección de cambio.
        Observe con qué frecuencia Angular llama este hook y lo observa poniendo cambios en el registro.
  tr(style=top)
    td <a href="#afterview">AfterView</a>
    td
      :marked
        Shows what Angular means by a *view*.
        Demonstrates the `ngAfterViewInit` and `ngAfterViewChecked` hooks.
        
        Muestra qué quiere decir Angular con una *vista*.
        Demuestra los hooks `ngAfterViewInit` y `ngAfterViewChecked`.
  tr(style=top)
    td <a href="#aftercontent">AfterContent</a>
    td
      :marked
        Shows how to project external content into a component and
        how to distinguish projected content from a component's view children.
        Demonstrates the `ngAfterContentInit` and `ngAfterContentChecked` hooks.
        
        Muestra cómo proyectar contenido externo en un componente y
        cómo distinguir contenido proyectado de la vista hija de un componente.
        Demuestra los hooks `ngAfterContentInit` y `ngAfterContentChecked`.
  tr(style=top)
    td Counter
    td
      :marked
        Demonstrates a combination of a component and a directive
        each with its own hooks.
        
        Demuestra una combinación de un componente y una directiva
        cada uno con sus propios hooks.

        In this example, a `CounterComponent` logs a change (via `ngOnChanges`)
        every time the parent component increments its input counter property.
        Meanwhile, we apply the `SpyDirective` from the previous example
        to the `CounterComponent` log and watch log entries be created and destroyed.
        
        En este ejemplo, un componente `CounterComponent` registra un cambio (vía `ngOnChanges`)
        cada vez que el componente padre incrementa su propiedad de entrada contador.
        Mientras tanto, se aplica la directiva `SpyDirective` del ejemplo anterior
        al registro del componente `CounterComponent` y observa entradas de registro creadas y destruídas.

:marked
  We discuss the exercises in further detail over this chapter as we learn more about the lifecycle hooks.
  
  Se habla de estos ejercicios a más detalle en este capítulo conforme se aprende más acerca de los hooks de ciclo de vida.

a(id="peek-a-boo")
.l-main-section
:marked
  ## Peek-a-boo: all hooks
  The `PeekABooComponent` demonstrates all of the hooks in one component.
  
  ## Peek-a-boo: todos los hooks
  El componente `PeekABooComponent` demuestra todos los hooks en un componente.

  In real life, we'd rarely if ever implement all of the interfaces like this.
  We do so in peek-a-boo in order to watch Angular call the hooks in the expected order.
  
  En la vida real, rara vez se tendrían que implementar todas las interfaces como esta.
  Se hizo en peek-a-boo con el fin de observar a Angular llamar a los hooks en el orden esperado.

  In this snapshot, we clicked the *Create...* button and then the *Destroy...* button.
  
  En esta captura, se hace clic en el botón *Create...* y después en el botón *Destroy...*.
figure.image-display
  img(src="/resources/images/devguide/lifecycle-hooks/peek-a-boo.png" alt="Peek-a-boo")
:marked
  The sequence of log messages follows the prescribed hook calling order:
  `OnChanges`, `OnInit`, `DoCheck`&nbsp;(3x), `AfterContentInit`, `AfterContentChecked`&nbsp;(3x),
  `AfterViewInit`, `AfterViewChecked`&nbsp;(3x), and `OnDestroy`.
  
  La secuencia de registro de mensajes seguidos de la llamada a hook prescrita es:
  `OnChanges`, `OnInit`, `DoCheck`&nbsp;(3x), `AfterContentInit`, `AfterContentChecked`&nbsp;(3x),
  `AfterViewInit`, `AfterViewChecked`&nbsp;(3x), y `OnDestroy`.

.l-sub-section
  :marked
    The constructor isn't an Angular hook *per se*.
    We log in it to confirm that input properties (the `name` property in this case) have no assigned values at construction.
    
    El constructor no es un hook de Angular *por sí mismo*.
    Se registra en él para confirmar que las propiedades de entrada (la propiedad `name` en este caso) no tenga valores asignados en la construcción.
:marked
  Had we clicked the *Update Hero* button, we'd have seen another `OnChanges` and two more triplets of
  `DoCheck`, `AfterContentChecked` and `AfterViewChecked`.
  Clearly these three hooks fire a *lot* and we must keep the logic we put in these hooks
  as lean as possible!
  
  Se ha hecho clic en el botón *Update Hero*, se ha visto otro `OnChanges` y dos tripletas más de 
  `DoCheck`, `AfterContentChecked` y `AfterViewChecked`.
  Evidentemente estos tres hooks se disparan *mucho* y se debe mantener la lógica que se puso en ellas
  ¡tan reducida como sea posible!

  Our next examples focus on hook details.
  
  Los siguientes ejemplos se enfocan en los detalles de los hooks.

.a(id="spy")
.l-main-section
:marked
  ## Spying *OnInit* and *OnDestroy*
  
  ## Espiando al *OnInit* y *OnDestroy*

  We're going undercover for these two hooks. We want to know when an element is initialized or destroyed,
  but we don't want *it* to know we're watching.
  
  Se hablará sobre estos hooks. Se quiere saber cuándo un elemento es inicializado o destruido,
  pero no se quiere que el *elemento* sepa que estamos observando.

  This is the perfect infiltration job for a directive.
  Our heroes will never know it's there.
  
  Este es el trabajo de infiltración perfecto para una directiva.
  Los héroes nunca sabrán que está ahí.

.l-sub-section
  :marked
    Kidding aside, we're emphasizing two key points:
    
    Dejando de lado la broma, se están enfatizando dos puntos clave:

    1. Angular calls hook methods for *directives* as well as components.
    
    1. Angular llama a los métodos hook para *directivas* también como componentes.

    2. A spy directive can gives us insight into a DOM object that we cannot change directly.
    Obviously we can't change the implementation of a native `div`.
    We can't modify a third party component either.
    But we can watch both with a directive.
    
    2. Una directiva espía da una idea del objeto DOM que no se puede cambiar directamente.
    Obviamente no se puede cambiar la implementacion de un `div` nativo.
    No se puede modificar un componente de terceros tampoco.
    Pero se pueden observar ambos con una directiva.


:marked
  Our sneaky spy directive is simple,  consisting almost entirely of `ngOnInit` and `ngOnDestroy` hooks
  that log messages to the parent via an injected `LoggerService`.
  
  La sigilosa directiva espía es simple, consiste casi enteramente de los hooks `ngOnInit` y `ngOnDestroy`
  que registran mensajes al padre vía un servicio `LoggerService` inyectado.

+makeExample('lifecycle-hooks/ts/app/spy.directive.ts', 'spy-directive')(format=".")

:marked
  We can apply the spy to any native or component element and it'll be initialized and destroyed
  at the same time as that element.
  Here we attach it to the repeated hero `<div>`
  
  Se puede aplicar el espionaje a cualquier elemento o componente nativo y será inicializado y destruido
  al mismo tiempo que ese elemento.
  Aquí se adjunta a un `<div>` de héroe repetido
+makeExample('lifecycle-hooks/ts/app/spy.component.html', 'template')(format=".")

:marked
  Each spy's birth and death marks the birth and death of the attached hero `<div>`
  with an entry in the *Hook Log* as we see here:
  
  Cada nacimiento y muerte de espías marca el nacimiento y muerte del `<div>` de héroe adjuntado
  con una entrada en el *registro de Hook* como se muestra aquí:

figure.image-display
  img(src='/resources/images/devguide/lifecycle-hooks/spy-directive.gif' alt="Spy Directive")

:marked
  Adding a hero results in a new hero `<div>`. The spy's `ngOnInit` logs that event.
  We see a new entry for each hero.
  
  Agregar un héroe resulta en un nuevo `<div>` de héroe. El espía de `ngOnInit` registra ese evento.
  Se observa una nueva entrada por cada héroe.

  The *Reset* button clears the `heroes` list.
  Angular removes all hero divs from the DOM and destroys their spy directives at the same time.
  The spy's `ngOnDestroy` method reports its last moments.
  
  El botón *Reset* limpia la lista `heroes`.
  Angular elimina todos los divs de héroe del DOM y destruye sus directivas espía al mismo tiempo.
  El espía del método `ngOnDestroy` reporta sus últimos momentos.

  The `ngOnInit` and `ngOnDestroy` methods have more vital roles to play in real applications.
  Let's see why we need them.
  
  Los métodos `ngOnInit` y `ngOnDestroy` tienen más roles vitales para jugar en aplicaciones reales.
  Veamos por qué son necesarios.

  ### OnInit
  
  ### OnInit

  We turn to `ngOnInit` for two main reasons:
  1. To perform complex initializations shortly after construction
  1. To set up the component after Angular sets the input properties
  
  Se trabaja con `ngOnInit` por dos razones principales:
  1. Para realizar inicializaciones complejas poco después de la construcción
  1. Para configurar el componente después de que Angular configura las propiedades de entrada

  An `ngOnInit` often fetches data for the component as shown in the
  [Tutorial](../tutorial/toh-pt4.html#oninit) and [HTTP](server-communication.html#oninit) chapters.
  
  Un `ngOnInit` a menudo trae datos para el componente como se muestra en los
  capítulos [Tutorial](../tutorial/toh-pt4.html#oninit) y [HTTP](server-communication.html#oninit).

  We don't fetch data in a component constructor. Why?
  Because experienced developers agree that components should be cheap and safe to construct.
  We shouldn't worry that a new component will try to contact a remote server when
  created under test or before we decide to display it.
  Constructors should do no more than set the initial local variables to simple values.
  
  No se traen datos en un constructor de componente. ¿Por qué?
  Porque los desarrolladores experimentados concuerdan que esos componentes deberían ser baratos y seguros de construir.
  No debería haber preocupación de que un componente nuevo intente contactar a un servidor remoto cuando
  es creado bajo prueba o antes de que se decida mostrar.
  Los constructores deberían no hacer más que establecer las variables locales iniciales a valores simples.

  When a component must start working _soon_ after creation,
  we can count on Angular to call the `ngOnInit` method to jumpstart it.
  That's where the heavy initialization logic belongs.
  
  Cuando un componente debe empezar a trabajar _pronto_ después de su creación,
  se pueden contar con Angular para llamar al método `ngOnInit` para un buen inicio.
  Es ahí a donde la lógica de inicialización robusta pertenece.

  Remember also that a directive's data-bound input properties are not set until _after construction_.
  That's a problem if we need to initialize the directive based on those properties.
  They'll have been set when our `ngOninit` runs.
  
  Recuerde también que las propiedades de entrada enlazadas a datos de las dirctivas no son establecidatas hasta _después de la construcción_.
  Ese es un problema si se necesita inicializar la directiva basada en esas propiedades.
  Ellas han sido establecidas cuando se ejecutó el `ngOninit`.
.l-sub-section
  :marked
    Our first opportunity to access those properties is the `ngOnChanges` method which
    Angular calls before `ngOnInit`. But Angular calls `ngOnChanges` many times after that.
    It only calls `ngOnInit` once.
    
    La primer oportunidad para accesar a esas propiedades es el método `ngOnChanges` al que
    Angular llama antes de `ngOnInit`. Pero Angular llama a `ngOnChanges` muchas veces después de eso.
    Sólo llama a `ngOnInit` una vez.
:marked
  ### OnDestroy
  
  ### OnDestroy

  Put cleanup logic in `ngOnDestroy`, the logic that *must* run before Angular destroys the directive.
  
  Ponga la lógica de limpieza en `ngOnDestroy`, la lógica que se *debe* ejecutar antes de que Angular destruya la directiva.

  This is the time to notify another part of the application that this component is going away.
  
  Este es el tiempo de notificar a otra parte de la aplicación que este componente se va.

  This is the place to free resources that won't be garbage collected automatically.
  Unsubscribe from observables and DOM events. Stop interval timers.
  Unregister all callbacks that this directive registered with global or application services.
  We risk memory leaks if we neglect to do so.
  
  Este es el lugar para liberar recursos que no serán basura recolectada automáticamente.
  Desuscribir observables y eventos del DOM. Parar temporizadores de intervalos.
  Anular el registro de todas las callbacks que esta directiva registró con servicios globales o de aplicación.
  Se arriesga a perder memoria si se descuida esto.

.l-main-section
:marked
  ## OnChanges
  
  ## OnChanges

  We monitor the `OnChanges` hook in this example.
  Angular calls its `ngOnChanges` method whenever it detects changes to ***input properties*** of the component (or directive).
  
  Se monitorea el hook `OnChanges` en este ejemplo.
  Angular llama a su método `ngOnChanges` cuando detecta cambios a ***propiedades de entrada*** del componente (o directiva).

  Here is our implementation of the hook.
  
  Aquí está la implementación del hook.
+makeExample('lifecycle-hooks/ts/app/on-changes.component.ts', 'ng-on-changes', 'OnChangesComponent (ngOnChanges)')(format=".")
:marked
  The `ngOnChanges` method takes an object that maps each changed property name to a
  [SimpleChange](../api/core/index/SimpleChange-class.html) object with the current and previous property values.
  We iterate over the changed properties and log them.
  
  El método `ngOnChanges` toma un objeto que mapea cada nombre de propiedad cambiada a un 
  objeto [SimpleChange](../api/core/index/SimpleChange-class.html) con los valores actual y anterior de la propiedad.

  The input properties for our example `OnChangesComponent` are `hero` and `power`.
  
  Las propiedades de entrada para el ejemplo `OnChangesComponent` son `hero` y `power`.
+makeExample('lifecycle-hooks/ts/app/on-changes.component.ts', 'inputs')(format=".")
:marked
  The parent binds to them like this:
  
  El padre se enlaza a ellas así:

+makeExample('lifecycle-hooks/ts/app/on-changes-parent.component.html', 'on-changes')
:marked
  Here's the sample in action as we make changes.
  
  Aquí esta el ejemplo en acción conforme se hacen los cambios.

figure.image-display
  img(src='/resources/images/devguide/lifecycle-hooks/on-changes-anim.gif' alt="OnChanges")

:marked
  We see log entries as the string value of the *power* property changes. But the `ngOnChanges` did not catch changes to `hero.name`
  That's surprising at first.
  
  Se observan entradas de registro conforme cambia el valor de cadena de la propiedad *power*. Pero el `ngOnChanges` no toma los cambios a `hero.name` 
  Eso es sorprendente al principio.

  Angular only calls the hook when the value of the input property changes.
  The value of the `hero` property is the *reference to the hero object*.
  Angular doesn't care that the hero's own `name` property changed.
  The hero object *reference* didn't change so, from Angular's perspective, there is no change to report!
  
  Angular sólo llama al hook cuando el valor de las propiedades de entrada cambia.
  El valor de la propiedad `hero` es la *referencia al objeto héroe*.
  Angular no tiene cuidado de que la propiedad `name` del héroe cambió.
  La *referencia* del objeto héroe no cambió, de modo que desde la perspectiva de Angular, ¡No hay cambio que reportar!

.l-main-section
:marked
  ## DoCheck
  We can use the `DoCheck` hook to detect and act upon changes that Angular doesn't catch on its own.
  
  ## DoCheck
  Se puede utilizar el hook `DoCheck` para detectar y actuar sobre los cambios que Angular no toma por sí mismo.
.l-sub-section
  :marked
    With this method we can detect a change that Angular overlooked.
    What we do with that information to refresh the display is a separate matter.
    
    Con este método se puede detectar un cambio que Angular pasó por alto.
    Lo que se hace con esa información para actualizar lo que se muestra es un asunto aparte.
:marked
  The *DoCheck* sample extends the *OnChanges* sample with this implementation of `DoCheck`:
  
  El ejemplo *DoCheck* se extiende del ejemplo *OnChanges* con esta implementación del `DoCheck`:
+makeExample('lifecycle-hooks/ts/app/do-check.component.ts', 'ng-do-check', 'DoCheckComponent (ngDoCheck)')(format=".")
:marked
  We manually check everything that we care about, capturing and comparing against previous values.
  We write a special message to the log when there are no substantive changes
  to the hero or the power so we can keep an eye on the method's performance characteristics.
  
  Manualmente se comprueba todo de lo que se tiene cuidado, capturando y comparando con valores anteriores.
  Se escribe un mensaje especial al registro cuando no hay cambios sustanciales
  al héroe o al poder así que se puede poner atención en las características del rendimiento del método.

  The results are illuminating:
  
  Los resultados son esclarecedores:

figure.image-display
  img(src='/resources/images/devguide/lifecycle-hooks/do-check-anim.gif' alt="DoCheck")
:marked
  We now are able to detect when the hero's `name` has changed. But we must be careful.
  
  Ahora hay la capacidad para detectar cuando el `name` del héroe ha cambiado. Pero se debe tener cuidado.

  The `ngDoCheck` hook is called with enormous frequency &mdash;
  after _every_ change detection cycle no matter where the change occurred.
  It's called over twenty times in this example before the user can do anything.
  
  El hook `ngDoCheck` es llamada con enorme frecuencia &mdash;
  después de _cada_ ciclo de detección de cambio sin importar dónde ocurrió el cambio.
  Es llamado alrededor de 20 veces en este ejemplo antes de que el usuario pueda hacer cualquier cosa.

  Most of these initial checks are triggered by Angular's first rendering of *unrelated data elsewhere on the page*.
  Mere mousing into another input box triggers a call.
  Relatively few calls reveal actual changes to pertinent data.
  Clearly our implementation must be very lightweight or the user experience may suffer.
  
  La mayoría de estas comprobaciones iniciales son disparadas por el primer renderizado de Angular de *datos no relacionados en otras partes de la página*.
  Un simple paso del mouse en otro compo de entrada llama una función.
  Relativamente algunas llamadas revelan cambios actuales a datos pertinentes.
  Evidentemente la implementación debe ser muy ligera o la experiencia del usuario puede sufrir. 

.l-sub-section
  :marked
    We also see that the `ngOnChanges` method is called in contradiction of the
    [incorrect API documentation](../api/core/index/DoCheck-class.html).
    
    También se observa que el método `ngOnChanges` es llamado en contradicción de la
    [documentación de la API incorrecta](../api/core/index/DoCheck-class.html).

.l-main-section
:marked
  ## AfterView
  The *AfterView* sample explores the `AfterViewInit` and `AfterViewChecked` hooks that Angular calls
  *after* it creates a component's child views.
  
  ## AfterView
  El ejemplo *AfterView* explora los hooks `AfterViewInit` y `AfterViewChecked` que Angular llama
  *después* de que crea unas vistas hijas del componente.

  Here's a child view that displays a hero's name in an input box:
  
  Aquí está una vista hija que muestra un nombre de héroe en un campo de entrada:
+makeExample('lifecycle-hooks/ts/app/after-view.component.ts', 'child-view', 'ChildComponent')(format=".")
:marked
  The `AfterViewComponent` displays this child view *within its template*:
  
  El componente `AfterViewComponent` muestra esta vista hija *dentro de su plantilla*:
+makeExample('lifecycle-hooks/ts/app/after-view.component.ts', 'template', 'AfterViewComponent (template)')(format=".")
:marked
  The following hooks take action based on changing values *within the child view*
  which we can only reach by querying for the child view via the property decorated with
  [@ViewChild](../api/core/index/ViewChild-var.html).
  
  Los siguientes hooks tienen acción basados en cambiar valores *dentro de la vista hija*
  que sólo se puede alcanzar consultando a la vista hija vía la propiedad decorada con 
  [@ViewChild](../api/core/index/ViewChild-var.html).

+makeExample('lifecycle-hooks/ts/app/after-view.component.ts', 'hooks', 'AfterViewComponent (class excerpts)')(format=".")
.a(id="wait-a-tick")
:marked
  ### Abide by the unidirectional data flow rule
  The `doSomething` method updates the screen when the hero name exceeds 10 characters.
  
  ### Acatar la regla de flujo de datos unidireccional
  El método `doSomething` actualiza la pantalla cuando el nombre del héroe excede los 10 caracteres.

+makeExample('lifecycle-hooks/ts/app/after-view.component.ts', 'do-something', 'AfterViewComponent (doSomething)')(format=".")
:marked
  Why does the `doSomething` method wait a tick before updating `comment`?
  
  ¿Por qué el método `doSomething` espera un poco antes de actualizar `comment`?

  Because we must adhere to Angular's unidirectional data flow rule which says that
  we may not update the view *after* it has been composed.
  Both hooks fire after the component's view has been composed.
  
  Porque se debe apegar a la regla de flujo de datos unidireccional de Angular que dice que
  se no se puede actualizar la vista *después* de que ha sido compuesta.
  Ambos hooks se disparan después de que la vista del componente ha sido compuesta.

  Angular throws an error if we update component's data-bound `comment` property immediately (try it!).
  
  Angular lanza un error si se actualiza el enlace de datos de la propiedad `comment` del componente inmediatamente (¡Pruébelo!).
block tick-methods
  :marked
    The `LoggerService.tick` methods, which are implemented by a call to `setTimeout`, postpone the update one turn of the of the browser's JavaScript cycle ... and that's long enough.
    
    Los métodos `LoggerService.tick`, que son implementados llamando a `setTimeout`, posponen la actualización una vuelta del ciclo JavaScript del navegador ... y eso es suficientemente largo.

:marked
  Here's *AfterView* in action
  
  Aquí está el *AfterView* en acción.
figure.image-display
  img(src='/resources/images/devguide/lifecycle-hooks/after-view-anim.gif' alt="AfterView")
:marked
  Notice that Angular frequently calls `AfterViewChecked`, often when there are no changes of interest.
  Write lean hook methods to avoid performance problems.
  
  Note que Angular frecuentemente llama a `AfterViewChecked`, a menudo cuando no hay cambios de interés.
  Escriba métodos hook de apoyo para evitar problemas de rendimiento.

.l-main-section
:marked
  ## AfterContent
  The *AfterContent* sample explores the `AfterContentInit` and `AfterContentChecked` hooks that Angular calls
  *after* Angular projects external content into the component.
  
  ## AfterContent
  El ejemplo *AfterContent* explora los hooks `AfterContentInit` y `AfterContentChecked` que Angular llama
  *después* de que Angular proyecta contenido externo en el componente.

  ### Content projection
  *Content projection* is a way to import HTML content from outside the component and insert that content
  into the component's template in a designated spot.
  
  ### Proyección de contenido 
  La *Proyección de contenido* es una manera de importar contenido HTML de afuera del componente e insertar ese contenido
  en la plantilla del componente en un espacio designado.

.l-sub-section
  :marked
    Angular 1 developers know this technique as *transclusion*.
    
    Los desarrolladores de Angular 1 conocen esta técnica como *transclusión*.

:marked
  We'll illustrate with a variation on the [previous](#afterview) example
  whose behavior and output is almost the same.
  
  Se ilustrará con una variación del ejemplo [anterior](#afterview)
  cuyo comportamiento y salida es casi la misma.

  This time, instead of including the child view within the template, we'll import it from
  the `AfterContentComponent`'s parent. Here's the parent's template.
  
  Esta vez, en lugar de incluír la vista hija dentro de la plantilla, se importará desde
  el padre del componente `AfterContentComponent`. Aquí está la plantilla del padre.
+makeExample('lifecycle-hooks/ts/app/after-content.component.ts', 'parent-template', 'AfterContentParentComponent (template excerpt)')(format=".")
:marked
  Notice that the `<my-child>` tag is tucked between the `<after-content>` tags.
  We never put content between a component's element tags *unless we intend to project that content
  into the component*.
  
  Note que la etiqueta `<my-child>` está colocada entre las etiquetas `<after-content>`.
  Nunca se coloca contenido entre etiquetas de elemento de un componente *a menos de que se intente proyectar ese contenido
  en el componente*.

  Now look at the component's template:
  
  Ahora veamos la plantilla del componente:
+makeExample('lifecycle-hooks/ts/app/after-content.component.ts', 'template', 'AfterContentComponent (template)')(format=".")
:marked
  The `<ng-content>` tag is a *placeholder* for the external content.
  They tell Angular where to insert that content.
  In this case, the projected content is the `<my-child>` from the parent.
  
  La etiqueta `<ng-content>` es una *marca* para contenido externo.
  Le dice a Angular dónde insertar ese contenido.
  En este caso, el contenido proyectado es el `<my-child>` del padre.
figure.image-display
  img(src='/resources/images/devguide/lifecycle-hooks/projected-child-view.png' width="230" alt="Projected Content")
:marked
.l-sub-section
  :marked
    The tell-tale signs of *content projection* are (a) HTML between component element tags
    and (b) the presence of `<ng-content>` tags in the component's template.
    
    El indicador señal de *proyección de contenido* es (a) HTML entre etiquetas de elemento del componente 
    y (b) la presencia de las etiquetas `<ng-content>` en la plantilla del componente.
:marked
  ### AfterContent hooks
  *AfterContent* hooks are similar to the *AfterView* hooks. The key difference is the kind of child component
  that we're looking for.
  
  ### Hooks AfterContent
  Los hooks *AfterContent* son similares a los hooks *AfterView*. La diferencia clave es el tipo de componente hijo
  que se busca.

  * The *AfterView* hooks concern `ViewChildren`, the child components whose element tags
  appear *within* the component's template.
  
  * Los hooks *AfterView* se refieren a `ViewChildren`, los componentes hijos cuyas etiquetas de elemento
  aparecen *dentro* de la plantilla del componente.

  * The *AfterContent* hooks concern `ContentChildren`, the child components that Angular
  projected into the component.
  
  * Los hooks *AfterContent* se refieren a `ContentChildren`, los componentes hijo que Angular
  proyecta en el componente.

  The following *AfterContent* hooks take action based on changing values in a  *content child*
  which we can only reach by querying for it via the property decorated with
  [@ContentChild](../api/core/index/ContentChild-var.html).
  
  Los siguientes hooks *AfterContent* tienen acción basados en el cambio de valores en un *contenido hijo*
  que sólo se puede alcanzar consultándolos vía la propiedad decorada con 
  [@ContentChild](../api/core/index/ContentChild-var.html).

+makeExample('lifecycle-hooks/ts/app/after-content.component.ts', 'hooks', 'AfterContentComponent (class excerpts)')(format=".")

:marked
  ### No unidirectional flow worries
  
  ### Sin preocupaciones de flujo unidireccional

  This component's `doSomething` method update's the component's data-bound `comment` property immediately.
  There's no [need to wait](#wait-a-tick).
  
  Este método `doSomething` del componente actualiza la propiedad enlazada a datos `comment` inmediatamente.
  No hay [necesidad de esperar](#wait-a-tick).

  Recall that Angular calls both *AfterContent* hooks before calling either of the *AfterView* hooks.
  Angular completes composition of the projected content *before* finishing the composition of this component's view.
  We still have a window of opportunity to modify that view.
  
  Recordar que Angular llama ambos hooks *AfterContent* antes de llamar a los hooks *AfterView*.
  Angular completa la composición del contenido proyectado *antes* de finalizar la composición de esta vista del componente.
  Se sigue teniendo una ventana de oportunidades para modificar esa vista.
